<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/general_transition_engine.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/general_transition_engine.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const AppLifeCycle = require("./general_lifecyle")
const fs_pr = require('fs/promises')

const DEFAULT_TRANSITION_ENDPOINT = "./transition-endpoint-server"

/** 
 * especially useful for uploaders or other types of processes that 
 * use a backend servrer conversation in order to expose validated endpoints
 * to the user facing services (web servers)
 */
class EndpointManager extends AppLifeCycle {

    constructor() {
        super()
        this.trans_processor = false
        this.user_processor = false
        this.endpoint_service = false
    }

    initialize_endpoint_services(conf) {
        if ( conf === undefined ) return
        //
        let TransitionalEndpoint = require((conf.endpoint_module !== undefined) ? conf.endpoint_module : DEFAULT_TRANSITION_ENDPOINT)
        this.endpoint_service = new TransitionalEndpoint(conf)
        this.endpoint_service.set_transition_handler(async (transition,msg_obj) => {
            // called from app_message_handler  (see endpoint service message-relay-services)
            let server_id = msg_obj ? msg_obj.server_id : false
            if ( server_id &amp;&amp; this.trans_processor ) {      // transitional
                let result = await this.trans_processor.endpoint_transition(transition,msg_obj)
                return result[1]  // this will send back the JSON object without HTTP status codes
            } 
        })

        this.endpoint_service.set_mime_handler(async (asset,msg_obj) => {
            // called from app_message_handler  (see endpoint service message-relay-services)
            let server_id = msg_obj ? msg_obj.server_id : false
            if ( server_id &amp;&amp; this.this.mime_processor ) {      // transitional
                msg_obj._x_c$trns_path = "set_mime_handler"
                let result = await this.this.mime_processor.static_asset_handler(asset,msg_obj)
                return [result[1] ,result[2]] // [1] is mime type object, [2] is a string determined by the app
            }
        })
        //
        return {}
    }

}


/** 
 * provides a pathway for transition requests to enter into the conractual processing
 * via web sockets.
 */
class WebSocketActions extends EndpointManager {

    constructor() {
        super()
        this.web_sockets = false
    }

    set_contractual_filters(trans_processor,user_processor,mime_processor) {
        this.trans_processor = trans_processor
        this.user_processor = user_processor
        this.mime_processor = mime_processor
    }

    set_ws(web_sockets) {
        this.web_sockets = web_sockets
    }

}



/** 
 * The General Transition Engine provides basic transitions for files and media while keeping the 
 * abstraction for managing and executing transtions which may be of varying complexity and asynchronicity.
 * 
 * Ideally, the most advanced transition engine will operate distributed ATMs or Petri nets with the web interface
 * taking part a an active input driver from among many input drivers.
 */

class GeneralTransitionEngImpl extends WebSocketActions {
    //
    constructor() {
        super()
        this.db = null
        this.statics = null
        this.dynamics = null
        this._uploader_managers = {}
        this.root_path = process.mainModule.path
    }

    initialize(conf,db) {
        this.conf = conf
        this.db = db
        if ( (conf.transition_endpoint !== undefined) &amp;&amp; (typeof conf.transition_endpoint === 'object') ) {
            this.initialize_endpoint_services(conf.transition_endpoint)
        }
    }

    install(statics_assets,dynamics_assets,sessions) {
        this.sessions = sessions
        this.statics = statics_assets
        this.dynamics = dynamics_assets
        this.statics.set_transition_engine(this)
        this.dynamics.set_transition_engine(this)
        dynamics_assets.import_keys(this.get_import_key_function())
    }

    get_import_key_function() {
        return(false)
    }

    chunks_to_data(blob_data) {
        return Buffer.concat(blob_data)
    }


    async file_mover(file_descriptor,target_path,trans_obj,cb) {
        file_descriptor.mv(target_path,cb)
        return(Math.floor(Math.random()*10000)) // default random int
    }

    async store_data(file_descriptor,target_path,writeable_data,id) {
        await fs_pr.writeFile(target_path,writeable_data)
        return id
    }


    async update_meta_descriptors(post_body,ids) {}

    alt_store() { return false }
    app_pack_data(blob_data) {}


    // chunk_mover
    // per file chunk mover
    async chunk_mover(token,file_descriptor,target_path,cb) {
        //
        let chunk_manager = this._uploader_managers[token]
        let blob_data = false
        if ( chunk_manager._chunks !== undefined ) {            // ONE FILE -- one array of chunks
            blob_data = chunk_manager._chunks
        } else if ( chunk_manager._chunkers !== undefined ) {       // MANY FILES -- map file names to arrays of chunks
            blob_data = chunk_manager._chunkers[file_descriptor.name]
        } else {
            // COULD NOT PERFORM OP
            return false
        }
        let id = false
        if ( blob_data ) {
            let writeable_data = this.alt_store() ? this.app_pack_data(blob_data) : this.chunks_to_data(blob_data)
            id = await this.store_data(file_descriptor,target_path,writeable_data,id)   
        }
        try {
            if ( cb ) cb()
        } catch (e) {}
        //
        return(id)
    }

    // files_coming_in_chunks
    //  Set up a data structure that can be found by the ...transaction token... 
    //  and that refers to an array that can receive chunks (one or more files as separate cases)
    //  when a file list is givent, the files are keyed by the file name under the transaction token 
    //  -> (file names will not be confused with other sessions)
    files_coming_in_chunks(post_body,token) {
        let chunk_manager = Object.assign({},post_body)
        if ( post_body.file_list ) {            // MULTIPLE FILES. for clients sending more than one file, a list is expected beyond the typical form field list
            chunk_manager._chunkers = {}
            for ( let file of post_body.file_list ) {   // EACH of file list
                if ( file.file_name !== undefined ) {
                    chunk_manager._chunkers[file.file_name] = []   // chunks  // each file in the list has to have at least a name
                }
            }
        } else {
            chunk_manager._chunks = []          // ONE FILE only
        }
        this._uploader_managers[token] = chunk_manager    // &lt;-- transaction token gets a chunk manager
    }

    //
    async upload_chunk(post_body,files) {
        if ( !files || Object.keys(files).length === 0) {
            let finalization_state = {
                "state" : "failed",
                "OK" : false
            }
            return finalization_state
        }
        //
        let token = post_body.token
        let f_keys =  Object.keys(files)
        let chunk_manager = this._uploader_managers[token]
        if (  (f_keys.length === 1) &amp;&amp; chunk_manager._chunks ) {         // Handling one file
            let file = files[f_keys[0]]
            if ( file.data ) {
                chunk_manager._chunks.push(file.data)
            } else if ( typeof file === "string" ) {
                chunk_manager._chunks.push(file)
            }
        } else {                            // Handling multiple files
            // in a sequece of chunks one or more files may be identified in the post body
            // the client will seize to send the smaller files while larger ones will be sent 
            // until post bodies indicate that there is no more data to come.
            if ( chunk_manager._chunkers ) {
                for ( let file_key in files ) {
                    let file = files[file_key]
                    let chunk_array = chunk_manager._chunkers[file_key]
                    if ( file &amp;&amp; chunk_array ) {
                        if ( file.data ) {
                            chunk_array.push(file.data)
                        } else if ( typeof file === "string" ) {
                            chunk_array.push(file)
                        }
                    }
                }    
            }
        }
        let finalization_state = {
            "state" : "next",
            "OK" : true
        }
        return finalization_state
    }


    async chunks_complete(post_body,ttrans) {
        //
        let ids =  []
        let token = post_body.token

        if ( this._uploader_managers[token] !== undefined )  {
            // the file_list is sent in the body. 
            // they may have fallen out from the upload process.
            // But, it is expected that the client will send the list of all files
            // in the completion post body.
            if ( post_body.file_list ) {        // MORE THAN ONE
                for ( let uploaded_file of post_body.file_list ) {
                    let ext = uploaded_file.ext ? uploaded_file.ext : "media"
                    let file_differentiator = ttrans.file_entry_id("file")
                    let store_name = `${uploaded_file.name}${file_differentiator}.${ext}`
                    let dir = ttrans.directory()
                    //
                    let file_id = await this.chunk_mover(token,uploaded_file,dir + '/'  + store_name,false)
                    if ( file_id !== false ) {      // failed transaction will not return identifiers
                        ids.push(file_id)
                    }
                }
            } else {        // JUST ONE
                let uploaded_file = post_body.file
                let ext = post_body.ext ? post_body.ext : "media"
                let file_differentiator = ttrans.file_entry_id("file")
                let store_name = `${uploaded_file.name}${file_differentiator}.${ext}`
                let dir = ttrans.directory()
                //
                let file_id = await this.chunk_mover(token,uploaded_file,dir + '/'  + store_name,false)
                if ( file_id !== false ) {      // failed transaction will not return identifiers
                    ids.push(file_id)
                }
            }

        }
        //
        let finalization_state = {
            "state" : "stored",
            "OK" : "true",
            "ids" : ids
        }
        return finalization_state
    }

    //
    async upload_file(post_body,ttrans,files,req) {
        //
        if ( !files || Object.keys(files).length === 0) {
            let finalization_state = {
                "state" : "failed",
                "OK" : false
            }
            return finalization_state
        }
        //
        let ukey = ttrans.primary_key()
        let proto_file_name = post_body[ukey]
        let file_name_base = ttrans.transform_file_name(proto_file_name)
        let ext = post_body.file_type
        //
        let ids =  []
        for ( let file_key in files ) {
            let uploaded_file = files[file_key]
            let file_differentiator = ttrans.file_entry_id(file_key)
            // mv is part of the express.js system
            let store_name = `${file_name_base}${file_differentiator}.${ext}`
            let dir = ttrans.directory()
            let udata = {
                'name' : proto_file_name,
                'id-source' : ukey,
                'id' : proto_file_name,
                'pass' : '',
                'dir' : dir,
                'file' : store_name
            }
            ttrans.update_file_db_entry(udata)
            let file_id = await this.file_mover(uploaded_file,dir + '/'  + store_name,ttrans,((uudata,ureq) => {
                    return((err) => {
                        if ( err ) {
                            if ( this.sessions ) {
                                this.sessions.session_accrue_errors("upload",uudata,err,ureq)
                            }
                        } else {
                            this.db.store("upload",uudata)
                        }
                    });
                })(udata,req),udata)    
            //
            ids.push(file_id)
        }
        let finalization_state = {
            "state" : "stored",
            "OK" : "true",
            "ids" : ids
        }
        return finalization_state
    }
}


module.exports = GeneralTransitionEngImpl
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ApplicationCustomizationMethods.html">ApplicationCustomizationMethods</a></li><li><a href="CopiousTransitions.html">CopiousTransitions</a></li><li><a href="DBClass.html">DBClass</a></li><li><a href="DataLookupField.html">DataLookupField</a></li><li><a href="EmailField.html">EmailField</a></li><li><a href="EmailVerifyField.html">EmailVerifyField</a></li><li><a href="EndpointManager.html">EndpointManager</a></li><li><a href="FieldTest.html">FieldTest</a></li><li><a href="FieldValidatorTools.html">FieldValidatorTools</a></li><li><a href="FileMapper.html">FileMapper</a></li><li><a href="FilesAndRelays_base.html">FilesAndRelays_base</a></li><li><a href="ForeignAuth.html">ForeignAuth</a></li><li><a href="GeneralAppLifeCycle.html">GeneralAppLifeCycle</a></li><li><a href="GeneralAuth.html">GeneralAuth</a></li><li><a href="GeneralBusiness.html">GeneralBusiness</a></li><li><a href="GeneralDynamic.html">GeneralDynamic</a></li><li><a href="GeneralMiddleWare.html">GeneralMiddleWare</a></li><li><a href="GeneralStatic.html">GeneralStatic</a></li><li><a href="GeneralTransitionEngImpl.html">GeneralTransitionEngImpl</a></li><li><a href="GeneralUserDBWrapperImpl.html">GeneralUserDBWrapperImpl</a></li><li><a href="GeneralValidator.html">GeneralValidator</a></li><li><a href="LengthyAlphabetField.html">LengthyAlphabetField</a></li><li><a href="LengthyDigitalField.html">LengthyDigitalField</a></li><li><a href="LengthyField.html">LengthyField</a></li><li><a href="LengthyStringField.html">LengthyStringField</a></li><li><a href="LocalStaticDB.html">LocalStaticDB</a></li><li><a href="LocalStorageLifeCycle.html">LocalStorageLifeCycle</a></li><li><a href="LocalStorageSerialization.html">LocalStorageSerialization</a></li><li><a href="PageableMemStoreElement.html">PageableMemStoreElement</a></li><li><a href="PasswordField.html">PasswordField</a></li><li><a href="PasswordVerifyField.html">PasswordVerifyField</a></li><li><a href="ReMailer.html">ReMailer</a></li><li><a href="RemoteMessaging.html">RemoteMessaging</a></li><li><a href="SessionManager.html">SessionManager</a></li><li><a href="SessionManager_Lite.html">SessionManager_Lite</a></li><li><a href="SessionTokenManager.html">SessionTokenManager</a></li><li><a href="StaticDBDefault.html">StaticDBDefault</a></li><li><a href="TaggedTransition.html">TaggedTransition</a></li><li><a href="TokenTables.html">TokenTables</a></li><li><a href="TypeCheckField.html">TypeCheckField</a></li><li><a href="UserMessageEndpoint.html">UserMessageEndpoint</a></li><li><a href="WebSocketActions.html">WebSocketActions</a></li><li><a href="WebSocketManager.html">WebSocketManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#generate_password_block">generate_password_block</a></li><li><a href="global.html#load_configuration">load_configuration</a></li><li><a href="global.html#load_parameters">load_parameters</a></li><li><a href="global.html#module_top">module_top</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Oct 24 2023 22:42:35 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
