
<style>

  button {
    cursor: pointer;
  }
  button:disabled {
    cursor:default;
  }
  
    audio {
      display: block;
      margin: 5px;
    }
    .like-button {
      font-weight: 600;
      font-size:68%;
      font-family: Arial, Helvetica, sans-serif;
      background-color: rgb(250, 244, 218);
      margin-right: 4px;
      margin-left: 2px;
    }
    .wv_button {
      width: 50%;
    }
    .wv_button_wordy {
      width: 70%;
      font-size: 80%;
    }
    #saved-audio-messages {
      max-height: 256px;
      overflow-y: scroll;
    }
    .component-container {
      border: rgb(126, 79, 9) solid 2px;
      padding: 4px;
    }
    .audio-checks {
      float: left
    }
    .audio-playback {
      display: inline;
    }
    .playback-div {
      width:100%;
      text-align:left;
      vertical-align:bottom;
      border-bottom: midnightblue solid 1px;
      padding: 2px;
    }
    .pop-name-list {
      visibility: hidden;
      display: none;
    }
    .pop-name-list-popped {
      visibility: visible;
      display: block;
    }
  
    .wave-graph-container {
      left: 10px;
      top: 10px;
      width: 80%;
      height: 40%;
      position:absolute;
      display: none;
      visibility: none;
      z-index:500;
      border: 2px orangered solid;
      background-color: ivory;
    }
  
    .wave-graph-container button {
      font-size: 0.8em;
      cursor: pointer;
      font-weight: 600;
      background-color: rgb(250, 244, 218);
      border-radius: 6px;
      border: 1px double #cccccc;
      width:auto;
      padding-left: 4px;
      padding-right: 4px;
    }
  
    .drag-bar-control {
      margin:0px;
      width: 100%;
      height: 20px;
      background-color: slateblue;
      color:goldenrod;
      cursor:move;
      text-align: right;
    }
    .wave-graph-canvas {
      width: 100%;
      height: 100%;
    }
    .wv-editor-close {
      font-size: 120%;
      height:10px;
      width:10px;
      text-align: center;
      vertical-align: middle;
      cursor: pointer;
    }
    .wave_edit_controls_container {
      display:inline-block;
      width: calc(100% - 20px);
      text-align: center;
      height: 100%;
    }
  
    dialog {
      padding: 0;
      border: 0;
      border-radius: 0.4rem;
      padding: 6px;
      box-shadow: 0 0 1em black;
      background-color: rgb(221, 214, 221);
    }
  
    dialog::backdrop {
      background: rgba(200, 200, 160, 0.25);
    }
  
    .wv-bq-dialog {
      max-width: 600px;
      border:rgb(250, 244, 218) solid 1px;
      background-color: rgba(255, 245, 238, 0.603);
      color:rgb(24, 57, 83);
      font-weight:400;
    }

    .check_audio_element {
      min-height: 50px;
    }
  
  #audioBoxGhost {
    position : absolute;
    display : none;
    visibility: hidden;
    height : 0px;
    width : 0px;
    cursor : move;
    border : 2px dotted greenyellow;
    background-color: rgba(236, 236, 201, 0.445);
  }

</style>


<div class="component-container">
  <span style="font-weight: bolder;">Manage Recording Sessions</span>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
  <div class="like-button" style="display: inline;" >
    <label  for="wv-geo-location">Session Geolocation:</label>
    <span id="wv-geo-location">NaN,NaN</span>
  </div>
  
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
  <button class="wv_button" onclick="ask_user_session()" >New&nbsp;Recording&nbsp;Session</button>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
  <!--   -->
  <div class="like-button" style="display: inline;" >
  <label  for="sess-names" style="text-align: left;">Edit Existing Session:</label>
  <select name="sess-names" id="sess-names" onchange="edit_user_session(event)">
    <option value="none">no selection</option>
  </select>
  </div>
  <!--   -->
  <div>
  <button class="wv_button" id="send-session" onclick="download_prompt()" >Download&nbsp;Session</button>
  <button class="wv_button_wordy" id="delete-session" onclick="delete_session()" >Delete&nbsp;Session&nbsp;from&nbsp;Device</button>
  </div>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
  <!--   -->
  <span style="font-weight: bolder;">Record Audio</span>:&nbsp;&nbsp;&nbsp;&nbsp;
  <span id="show-session-name" style="font-weight: bolder;"></span>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
  <button id="record" disabled>Record</button>
  <button id="stop" disabled>Stop</button>
  <button id="play" disabled>Play</button>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>

  <span style="font-weight: bolder;">Save Audio</span>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
  <button id="save" disabled>Save</button>
  <button id="delete" disabled>Delete</button>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
  <div style="width: 98%;">
    <div style="font-weight: bolder;">Session Components:</div>
    <div style="display: inline;padding:2px;background-color: oldlace">
      <button class="wv_button" onclick="wv_edit_checked()" >edit&nbsp;checked</button>
      <button class="wv_button" onclick="wv_delete_checked()" >delete&nbsp;checked</button>
    </div>
  </div>
  <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;;margin-top: 2px;">&nbsp;</div>
  <div id="saved-audio-messages">
  </div>
</div>
<div id="wave-graph-tmplt" class='wave-graph-container'>
  <div class="drag-bar-control"
        onmousedown="wv_capture_cursor(event)"
        onmouseup="wv_release_captured_cursor(event,false)"
        onmouseout="wv_track_cursor_out(event,true)"
        onmousemove="wv_track_cursor(event)"
        onmouseenter="wv_check_cursor_entry(event)"
      >
        <div class="wave_edit_controls_container"
          onmousedown="wv_capture_cursor(event,1)"
          onmouseup="wv_release_captured_cursor(event,false,1)"
          onmouseout="wv_track_cursor_out(event,true,1)"
          onmousemove="wv_track_cursor(event,1)"
          onmouseenter="wv_check_cursor_entry(event,1)"
          >
          <button onclick="wv_zoom_in(event)">&downarrow;</button>
          <button onclick="wv_zoom_out(event)">&uparrow;</button>
          <button onclick="wv_scroll_left(event)">&leftarrow;</button>
          <button onclick="wv_scroll_right(event)">&rightarrow;</button>
          &nbsp;
          <button onclick="wv_cut_selection(event)">cut</button>
          <button onclick="wv_restore_selection(event)">undo</button>
        </div>
        <span class="wv-editor-close" onclick="wv_closer_editor(event)">x</span></div>
  <div style="width: 100%;height:calc(100% - 20px);">
    <canvas class="wave-graph-canvas"></canvas>
  </div>
</div>
<!-- wave template-->
<dialog id="user-dialog">
  <h3 class="modal-header">Please enter your information.</h3>
  <div class="modal-body">
    <blockquote class="wv-bq-dialog">You are seeing this dialog box because this browser does not know of a user 
      to associate with new media being created here. This information is being used to generate a secure key for cryptographically 
      signing the new media. A private key will be stored within your web browser on your device in an ecrypted format. This signing
      key will be decrypted each time you return to this web page. 
      <span style="color:tomato">Providing your information here will not automatically sign you up to our
      site nor will it make you the target of advertising.
      </span>
      <blockquote style="font-size: 75%;font-weight: 600;color:rgb(5, 167, 118)">
        A valid email format is required, and a name should be readable. Leading spaces will be trimmed and internal spaces will be converted to undescores.
      </blockquote>
    </blockquote>
      <blockquote class="wv-bq-dialog">
        <form method="dialog">
          <label for="wv-id-email">Your identifying email:</label>
          <input type="text" id="wv-id-email" name="wv-id-email" /><br>
          <label for="wv-id-machine">A name for you to use to identify your machine:</label>
          <input type="text" id="wv-id-machine" name="wv-id-machine" />
        </form>
      </blockquote>
  </div>
  <footer class="modal-footer">
    <button id="wv-OK" class="wv_button_wordy" type="button" style="font-size:90%">This is my information</button>
    <button id="wv-later" class="wv_button" type="button">Later</button>
  </footer>
</dialog>
<!-- end of dialog-->
<dialog id='wave-download-box'>
  <h3 class="modal-header">Click on the link below to begin downloading an audio file of this session</h3>
  <div class="modal-body">
    <blockquote class="wv-bq-dialog">
      <a id='wave-download-link' href = "" >no file</a>
    </blockquote>
  </div>
  <footer class="modal-footer">
    <button id="wave-download-cancel" type="button">Cancel</button>
  </footer>
</dialog>
<!-- end of dialog-->
<dialog id='verification-download-box'>
  <h3 class="modal-header">Click on the link below to begin downloading verification data</h3>
  <div class="modal-body">
    <blockquote class="wv-bq-dialog">
      <a id='verification-download-link' href = "" >no file</a>
    </blockquote>
  </div>
  <footer class="modal-footer">
    <button id="verification-download-cancel" type="button">Cancel</button>
  </footer>
</dialog>
<!-- end of dialog-->
<dialog id='session-transfer-box'>
  <h3 class="modal-header">Name a session to retrieve that you previously posted from another device</h3>
  <div class="modal-body">
    <form method="dialog">
      <label for="wv-id-email-transfer">Your identifying email:</label>
      <input type="text" id="wv-id-email-transfer" name="wv-id-email-transfer" />
      <br>
      <label for="wv-sess-name-transfer">Sesson Name:</label>
      <input type="text" id="wv-sess-name-transfer" name="wv-sess-name-transfer" />
    </form>
  </div>
  <footer class="modal-footer">
    <button id="wave-tranfer-cancel" type="button">Cancel</button>
    <button id="wave-tranfer-send" type="button">Request</button>
  </footer>
</dialog>
<div id="audioBoxGhost" >
    &nbsp;
</div>


<script>
const AUDIO_SESSION_STORE = 'audio_sessions'
const AUDIO_USERID_STORE = 'audio_users'
const AUDIO_SESSION_COMPLETE = 'audio_complete'
const WV_CONST_MOUSE_DRAG_DIST_TOLERANCE = 82
const WAVE_DISPLAY_MAX = 100
const ZERO_AXIS_OFFSET = 10
const THIRTY_SECONDS = 30000
const GEO_UPDATE_INTERVAL = THIRTY_SECONDS
const DB_VERSION = 5.0

//
// get a key for wrapping the local private key for storage between sessions.
const FETCH_SERVER_WRAPPER_KEY = '/song-search/guarded/dynamic/identified_key_wrapper_pub_key'
// Ask for the key to unlock the local copy of the user private key
const FETCH_SERVER_WRAPPER_KEY_RESTORE = '/song-search/guarded/dynamic/restore_key_wrapper_pub_key'
// Send the encrypted key to the server for off device storage (recommend a server separate from aes stored key)
const SEND_WRAPPED_RECORDING_KEY = '/song-search/transition/recording-key'
// Send entire session data to the server for later placement on another device belonging to the current user.
const REQ_AUDIO_SESSION_TRANSFER = '/song-search/guarded/dynamic/audio-session-transfer'
//
const APP_USER_SINGLETON = 'wave_recording_session_user'


//
let recorder = false
let audio = false
let g_app_recoder = false
let g_current_session_name = 'none'
let g_session_name_list = []
let g_preferred_download_format = 'audio/mpeg'
let g_wave_current_container = null

//
let g_wave_open_editors = {}
let g_wv_current_locaion = { 'latitude' : NaN,'longitude' : NaN}
let g_save_up_audio_elements = {}
let g_pub_verification_key = ""

//
let g_nonce_buffer = new Uint8Array((128/8))    // 16 bytes or 128 bit IV for AES

//
const g_recordButton = document.getElementById('record');
const g_stopButton = document.getElementById('stop');
const g_playButton = document.getElementById('play');
const g_saveButton = document.getElementById('save');
const g_deleteButton = document.getElementById('delete');
const g_send_session = document.getElementById('send-session')
//
const savedAudioMessagesContainer = document.querySelector('#saved-audio-messages');
const g_user_modal = document.getElementById('user-dialog');
const g_audio_download_modal = document.getElementById('wave-download-box')
const g_verify_download_modal = document.getElementById('verification-download-box')
const g_session_transfer_modal = document.getElementById('session-transfer-box')
var g_geo_update = null

var g_window_can_process = true
// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)

window.AudioContext = window.AudioContext || window.webkitAudioContext;
//

var g_beeper_snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
function beep() {
  g_beeper_snd.play();
}

var BASE64_MARKER = ';base64,';
//
function convertDataURIToBinary(dataURI) {
  var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
  var base64 = dataURI.substring(base64Index);
  var raw = window.atob(base64);
  var rawLength = raw.length;
  var array = new Uint8Array(new ArrayBuffer(rawLength));

  for(i = 0; i < rawLength; i++) {
    array[i] = raw.charCodeAt(i);
  }
  return array;
}

//
if ( typeof ensure_dialog_elements === "function" ) {
  ensure_dialog_elements()
}

//beep()

const g_audioContext = new AudioContext();

var g_crypto = window.crypto ? window.crypto.subtle : null
if ( g_crypto === null  ) {
  alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
}

if (!window.indexedDB) {
  g_window_can_process = false
  console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// OWNERSHIP WORKER!!!
let g_ownership_worker = new Worker('./hashers/ownership.js')

g_ownership_worker.onmessage = (msg) => {
  //
  if ( msg.data.type === 'status' ) {
    worker_status_view(msg.data.message)
  }
  //
  if ( msg.data.type === 'op_complete' ) {
    worker_op_response(msg.data.message);
  }
}

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>--
function get_client_device_name() {
    let oscpu = navigator.oscpu
    let ua = navigator.userAgent
    let user_given_machine_name = g_current_session_machine_name
    //
    let b = `${oscpu}-${ua}-${user_given_machine_name}`
    b = encodeURIComponent(b.trim())
    return(b)
}
//--<


function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}


function ext_from_download_format(download_format) {
  if ( download_format === 'audio/wave' ) {
    return("wav")
  }
  if ( download_format === 'audio/ogg' ) {
    return("ogg")
  }
  if ( download_format === 'audio/mpeg' ) {
    return("mp3")
  }
}

var g_current_session_signing_key = null
var g_current_session_email = ""
var g_current_session_machine_name = "tester"
function set_current_session_signing_key(key) {
  g_current_session_signing_key = key
}

function set_current_session_email(email) {
  g_current_session_email = email
}

function set_current_session_machine(machine_name) {
  g_current_session_machine_name = machine_name
}

//
class AppAudioRecorder {
  //  //  //
  constructor(stream) {
    //
    this.audioChunks = [];
    let mediaRecorder = new MediaRecorder(stream);
    this.mediaRecorder = mediaRecorder
    this.audio_instance = null
    this.section_id = 0
    //
    mediaRecorder.addEventListener('dataavailable', event => {
      this.data_handler(event)
    });

    mediaRecorder.addEventListener('stop',  event => {
      this.stop_handler(event)
    });
  }
  //
  //
  data_handler(data) {
    let chunk = event.data
    this.audioChunks.push(chunk);
    this.relayAudioData(chunk)
  }
  //
  start() {
    this.audioChunks = []
    this.mediaRecorder.start();
  }
  //
  stop_handler(event) {
    this.audio_results()
  }

  stop() {
    this.mediaRecorder.stop();
  }

  // audio_results
  // Called when recording stops.. This makes the first recod of a collection of audio chunks
  // A section ID is produced. The section ID will be used later when the user decideds to save 
  // the section... However, the section hash will be sent on to the server. (note: section v.s. session)
  async audio_results() {
    let audioBlob = new Blob(this.audioChunks);
    let audioUrl = URL.createObjectURL(audioBlob);
    this.audioBlob = audioBlob
    this.audio_instance = new Audio(audioUrl);
    let section_id = 'ER' + uuidv4() // use ER to signify End(Edit) Recording and be different than other randoms
    this.section_id = section_id
    await wv_backup_audio_chunks_for_verification(section_id,this.audioChunks)
    wv_secure('end-recording',audioBlob,section_id)
  }

  // add_current_data
  // Called when the user decides to save the audio as part of the named session
  // At this point, there is a section_id. It is used to make sure the indexedDB storage 
  // maps to the blob
  add_current_data() {
    if ( this.audioBlob ) {
      add_audio_data(this.audioBlob,this.section_id)
    }
  }

  delete_last_recorderd_audio() {
    this.audio_instance = null
    this.audioBlob = null
  }

  play() {
    if ( this.audio_instance ) {
      this.audio_instance.play()
    }
  }

  relayAudioData(chunk) {
    wv_prep_secure_relay(chunk)
  }


}

// DATABASE
var g_audio_db = null
const gc_song_db_name = "SongCatcher"
async function wv_init_database(db_name) {
  // request an open of DB
  let p = new Promise((resolve,reject) => {
    let request = window.indexedDB.open(db_name, DB_VERSION);
    //
    request.onerror = (event) => {
      alert("This web app will not store recorded audio without the use of computer storage.")
    };
    request.onsuccess = (event) => {
      //
      let db = event.target.result;
      db.onerror = (event) => {
        console.log("Database error: " + event.target.error);
        reject(event.target.error)
      };
      //
      g_audio_db = db;
      resolve(db)
    }

    request.onupgradeneeded = (event) => {
      let db = event.target.result;
      //
      try {
        let sessionObjectStore = db.createObjectStore(AUDIO_SESSION_STORE, { autoIncrement : true });
        sessionObjectStore.createIndex("name", "name", { unique: true });
        sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
      } catch (e) {
      }
      //
      try {
        db.createObjectStore(AUDIO_USERID_STORE, { autoIncrement : false, keyPath: 'app_key' });  // supposed to be just one
      } catch (e) {
      }
      //
      //
      try {
        let completeStore = db.createObjectStore(AUDIO_SESSION_COMPLETE, { autoIncrement : false, keyPath: 'name' });
        completeStore.createIndex("name", "name", { unique: true });
      } catch (e) {
      }
      //
    };

  })
  //
  return p
};



function apply_find_audio_session(sess_name, store, success_callback, not_found_callback) {
  //
  var nameIndex = store.index('name');
  nameIndex.get(sess_name).onsuccess = (evt) => {
    var value = evt.target.result;
    if ( value ) {
      if ( success_callback ) success_callback(value,nameIndex);
    } else {
      if ( not_found_callback ) not_found_callback();
    }
  };
  //
}



  ////////////////

class WaveBlob {
  constructor() {
    this.recLength = 0
    this.recBuffer = []
    this.recordSampleRate = g_audioContext.sampleRate
  }

  clear() {
    this.recLength = 0;
    this.recBuffer = [];
  }

  record(inputBuffer) {
    this.recBuffer.push(inputBuffer);
    this.recLength += inputBuffer.length;
  }

  toBlob(ctyp) {
    var mergedBuffers = this.interleaveLeftAndRight(this.recBuffer);
    var encodedWav = this.encodeWAV(mergedBuffers);
    var audioBlob = new Blob([encodedWav], {type: ctyp});
    return(audioBlob);
  }

  mergeBuffers(array_of_buffers, recLength) {
    let result = new Float32Array(recLength);
    let offset = 0;
    let n = array_of_buffers.length
    for ( let i = 0; i < n; i++ ) {
      result.set(array_of_buffers[i], offset);
      offset += array_of_buffers[i].length;
    }
    return result;
  }

  interleaveLeftAndRight(bufferList) {
    let left = bufferList[0]
    let right = bufferList[1]
    let totalLength = left.length + right.length;
    let data = new Float32Array(totalLength);
    let n = left.length
    for ( let i = 0; i < n; i++ ) {
      let k = i * 2;
      data[k] = left[i];
      data[k + 1] = right[i];
    }
    return(data)
  }


  // mutate output Int16
  floatTo16BitPCM(output, offset, input) {
    let n =  input.length
    for ( let i = 0; i < n; (i++, offset += 2) ) {
      let s = Math.max(-1, Math.min(1, input[i]));
      output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  }

  writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  encodeWAV(samples) {
    const WAV_HEAD_SIZE = 44
    let channels = 2
    let dat_len = samples.length * 2
    let buffer = new ArrayBuffer((dat_len * 2) + WAV_HEAD_SIZE)

    let view = new DataView(buffer);

    let recordSampleRate = this.recordSampleRate
    // RIFF chunk descriptor/identifier
    this.writeString(view, 0, 'RIFF')
    // RIFF chunk length
    view.setUint32(4, WAV_HEAD_SIZE + (dat_len * 2), true)  // 32
    // RIFF type
    this.writeString(view, 8, 'WAVE');
    // format chunk identifier
    // FMT sub-chunk
    this.writeString(view, 12, 'fmt ');
    // format chunk length
    view.setUint32(16, 16, true);
    // sample format (raw)
    view.setUint16(20, 1, true);
     // stereo (2 channels)
    view.setUint16(22, channels, true);
    // sample rate
    view.setUint32(24, recordSampleRate, true);
    // byte rate (sample rate * block align)
    view.setUint32(28, recordSampleRate * 2, true);
    // block align (channel count * bytes per sample)
    view.setUint16(32, (channels * 2), true);
    // bits per sample
    view.setUint16(34, 16, true);
    // data sub-chunk
    // data chunk identifier
    this.writeString(view, 36, 'data');
    // data chunk length
    view.setUint32(40, samples.length * 2, true);
    this.floatTo16BitPCM(view, 44, samples);


    return view;
  }

}

// ----
function make_audio_blob(channel_data_list) {
  let d1 = channel_data_list[0]
  let d2 = channel_data_list[1]
  let wb = new WaveBlob()
  wb.record(d1)
  wb.record(d2)
  //
  let blob = wb.toBlob('audio/wave')
  //
  return(blob)
}



async function concat_all_to_array(list_of_sections) {
  let start = list_of_sections.unshift()
  while ( list_of_sections.length ) {
    let next_sect = list_of_sections.unshift()
    start = start.concat(next_sect)
  }
  return(start)
}



// https://stackoverflow.com/questions/33702838/how-to-append-bytes-multi-bytes-and-buffer-to-arraybuffer-in-javascript
function concatTypedArrays(a, b) { // a, b TypedArray of same type
  var c = new (a.constructor)(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}

function wv_concat_sections(raw_sections) {
  let n = raw_sections.length
  let result_buffer = raw_sections.shift()
  while ( raw_sections.length ) {
    let next_buffer = raw_sections.shift()
    result_buffer = concatTypedArrays(result_buffer, next_buffer)
  }
  return result_buffer
}

async function make_complete_session_record(sess_name_cmplt,sessionObj,contentType) {
  // make a file storage format
  let raw_sections = []
  let mapkys = null
  if ( sessionObj.edit_order ) {
    mapkys = sessionObj.edit_order
    mapkys = mapkys.map(bid => {
      if ( bid.indexOf('audio-div-') === 0 ) {
        return bid.replace('audio-div-','')
      } else {
        return bid
      }
    })
  } else {
    mapkys = Object.keys(sessionObj.data)
  }
  //
  let n = mapkys.length
  for ( let i = 0; i < n; i++ ) {
    let wave_name = mapkys[i]
    let raw_wave = await get_wave_data(wave_name)
    raw_sections.push(raw_wave)
  }
  //
  let total_sections = wv_concat_sections(raw_sections)
  let audioBlob = make_audio_blob([total_sections,total_sections])
  //
  /*
  // TEST AUDIO
  let f_url = URL.createObjectURL(audioBlob);
  let test = new Audio(f_url)
  test.play()
  // 
  //
  try {
    //await remove_complete_if_exists(sess_name_cmplt)
  } catch (e) {
    console.log(e)
  }
  */
  try {
    await store_audio_key(sess_name_cmplt,audioBlob)
  } catch (e) {
    console.log(e)
  }
  //
}

 // ---- ---- ---- ---- ---- ---- ---- ----
 // ---- ---- ---- ---- ---- ---- ---- ----


var wv_checkEmailField = () => {}
var wv_fetchEndPoint = () => {}
var wv_postData = () => {}

if ( reEmail === undefined || typeof checkEmailField === 'undefined' ) {
  var reEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
  function checkEmailField(efield) {
    let email = efield.value
    if ( !(reEmail.test(email)) ) {
      return(false)
    }
    return(true)
  }
  wv_checkEmailField = checkEmailField
} else {
  wv_checkEmailField = checkEmailField
}

function wv_checkMachineNameField(nField) {
  let m_name = nField.value.trim()
  if ( m_name.length >= 1 ) {
    m_name = m_name.replace(' ','_')
    nField.value = m_name
    return true
  }
  return false
}

if ( typeof(fetchEndPoint) === "undefined" ) {
  async function fetchEndPoint(endpoint,port) {
    port = !(port) ? '' : ( port.length ? `:${port}`   : '')
    let myRequest = new Request(`${location.protocol}//${g_siteURL}${port}/${endpoint}`);
    try {
      const body = await fetch(myRequest, {
                    method: 'GET', // *GET, POST, PUT, DELETE, etc.
                    mode: 'cors', // no-cors, *cors, same-origin
                    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
                    credentials: 'omit', // include, *same-origin, omit
                    redirect: 'follow', // manual, *follow, error
                    referrerPolicy: 'no-referrer', // no-referrer, *client
                  });
      //
      let infoObj = await body.json();
      return(infoObj)
      //
    } catch (e) {
      console.log(e.message)
      return(false)
    }
  }
  wv_fetchEndPoint = fetchEndPoint
} else {
  wv_fetchEndPoint = fetchEndPoint
}


if ( typeof(postData) === "undefined" ) {
  async function postData(url = '', data = {}, creds = 'omit', do_stringify = true,ctype) {
    let content_type = 'application/json'
    if ( ctype !== undefined ) {
      content_type = ctype
    }
    let options = {
      method: 'POST', // *GET, POST, PUT, DELETE, etc.
      mode: 'cors', // no-cors, *cors, same-origin
      cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
      credentials: creds, // include, *same-origin, omit
      headers: {
        'Content-Type': content_type
      },
      redirect: 'follow', // manual, *follow, error
      referrerPolicy: 'no-referrer', // no-referrer, *client
      body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
    }

    if ( ctype === 'multipart/form-data') {
      delete options.headers['Content-Type']  // content type will be set automatically with a boundary
    }

    // Default options are marked with *
    const response = await fetch(url, options);
    if ( response.ok == false ) {
      console.log(response.status + ': ' + response.statusText)
      return {}
    } else {
      return await response.json(); // parses JSON response into native JavaScript objects
    }
  }
  wv_postData = postData
} else {
  wv_postData = postData
}

function init_user_dialog() {
  const modal = g_user_modal
  //
  const do_this_later = document.getElementById('wv-later');
  const ready_to_go = document.getElementById('wv-OK');
  //
  //dialogPolyfill.registerDialog(modal);

  do_this_later.addEventListener('click', () => {
    modal.close('cancelled');
  });

  modal.addEventListener('cancel', () => {
    //modal.close('cancelled');
  });

  // close when clicking on backdrop
  modal.addEventListener('click', (event) => {
    if (event.target === modal) {
      modal.close('cancelled');
    }
  });

  // 
  ready_to_go.addEventListener('click', () => {
    const email_value_holder = document.getElementById('wv-id-email')
    if ( wv_checkEmailField(email_value_holder) ) {
      const name_value_holder = document.getElementById('wv-id-machine')
      if ( wv_checkMachineNameField(name_value_holder) ) {
        modal.close('ready');
      } else {
        alert("Please enter a readable machine name of your choice, one or more characters :: spaces will be converted to undescores.")
      }
    } else {
      alert("Please enter a valid email address.")
    }
  });


  // AUDIO MODAL
  const dmodal = g_audio_download_modal
  const cancel_dmodal = document.getElementById('wave-download-cancel');

  dmodal.addEventListener('cancel', () => {
    //modal.close('cancelled');
  });

  // close when clicking on backdrop
  dmodal.addEventListener('click', (event) => {
    if (event.target === dmodal) {
      dmodal.close('cancelled');
    }
  });

  // 
  cancel_dmodal.addEventListener('click', () => {
    dmodal.close('cancelled');
  });


  // AUDIO MODAL
  const v_dmodal = g_verify_download_modal
  const v_cancel_dmodal = document.getElementById('verification-download-cancel');

  v_dmodal.addEventListener('cancel', () => {
    //modal.close('cancelled');
  });

  // close when clicking on backdrop
  v_dmodal.addEventListener('click', (event) => {
    if (event.target === v_dmodal) {
      v_dmodal.close('cancelled');
    }
  });

  // 
  cancel_dmodal.addEventListener('click', () => {
    v_dmodal.close('cancelled');
  });


  //

  // TRANSFER MODAL
  const tmodal = g_session_transfer_modal
  let temail_fld = document.getElementById('wv-id-email-transfer')
  let sess_name_fld = document.getElementById('wv-sess-name-transfer')
  let tsend_btn_fld = document.getElementById('wave-tranfer-send')
  let tcancel_btn_fld = document.getElementById('wave-tranfer-cancel')

  tmodal.addEventListener('cancel', () => {
    //modal.close('cancelled');
  });

  // close when clicking on backdrop
  tmodal.addEventListener('click', (event) => {
    if (event.target === tmodal) {
      tmodal.close('cancelled');
    }
  });

      // close when clicking on backdrop
  tsend_btn_fld.addEventListener('click', (event) => {
    if ( sess_name_fld && temail_fld ) {
      let email = temail_fld.value
      let sess_name = sess_name_fld.value
      if ( email.length && sess_name.length ) {
        request_transferred_session(email,sess_name)
        tmodal.close('sent');
        return;
      }
    }
    beep();
    return;
  });
  tsend_btn_fld.addEventListener('click', (event) => {
      tmodal.close('cancelled');
  });

}

//>--
// wv_keypair_promise
//  -- 
function wv_keypair_promise() {  // return 
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            'name': "ECDSA",
            'namedCurve': "P-384"
        },
        true,
        ["sign", "verify"]
    )
    return p  // promise
}
//--<

//>--
// wv_wrapper_keypair_promise
//  -- 
function wv_wrapper_keypair_promise() {  // return 
    // Generate a local public/private key pair
    let p =  g_crypto.generateKey({
            name: "RSA-OAEP",
            modulusLength: 4096, //can be 1024, 2048, or 4096
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }, //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
        },
        false,
        ["wrapKey","unwrapKey"]
    )
    return p  // promise
}
//--<


// wv_user_keys
//    make a priv/pub key pair. Then negotiate with the server to wrap the key.
async function wv_user_keys(user_email) {
  // Generate a local public/private key pair
  let keypair = await wv_keypair_promise()
  // ---- ---- ---- ----
  let pub_key = keypair.publicKey
  let priv_key = keypair.privateKey
  // ---- ---- ---- ----                                      // g_nonce_buffer - space to use
  let wrapped_key_info = await wv_wrap_private_key(priv_key,g_nonce_buffer,user_email)  // json object :: wrap private for local storage
  let exported = await g_crypto.exportKey("raw",pub_key);
  let exportedKeyBuffer = new Uint8Array(exported);
  let pub_key_str = hex_fromTypedArray(exportedKeyBuffer);
  g_pub_verification_key = pub_key_str

  let key_info = {
    "pk_str" : pub_key_str,
    "priv_key" : priv_key, // access this for now for signing
    "encrypted_key" : wrapped_key_info.encrypted_key,
    "key_session_id" : wrapped_key_info.who,            /// This is an id that identifies the user with the current device
    "iv" : wrapped_key_info.iv                          /// Initialization Vector for CBC
  }
  return(key_info)
}


function blobToBase64(blob) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onloadend = () => {
      resolve(reader.result);
    };
  });
}

//
async function store_audio_key(app_audio_key,audioBlob) {

  let storable = await blobToBase64(audioBlob)

  let p = new Promise((resolve,reject) => {
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_COMPLETE, "readwrite");
    transaction.oncomplete = (ev) => {
      console.log("store_audio_key: transaction done")
    }
    transaction.onerror = (ev) => {
      console.log(ev)
    }
    let audioStore = transaction.objectStore(AUDIO_SESSION_COMPLETE)

    //let blobArray = await audioBlob.arrayBuffer();
    //let a_view = new Uint8Array(blobArray)
    //let mapable = [...a_view];

    let storeObj = {
      'name' : app_audio_key,
      'blob' : storable,
      'pub_verification_key' : g_pub_verification_key
    }
    let result = audioStore.put(storeObj)
    result.onsuccess = (event) => {
      resolve(event.target.result)
    }
    result.error = (error) => {
      reject(error)
    }
  })
  return p
}

// //
async function get_audio_key(app_audio_key) {
  let p = new Promise((resolve,reject) => {
    let transaction = g_audio_db.transaction(AUDIO_SESSION_COMPLETE, "readwrite");
    let userStore = transaction.objectStore(AUDIO_SESSION_COMPLETE);
    
    let nameIndex = userStore.index('name');
    nameIndex.get(app_audio_key).onsuccess = (evt) => {
      let value = evt.target.result;
      if ( value ) {
        let keyRangeValue = IDBKeyRange.only(value.name);
        nameIndex.openCursor(keyRangeValue).onsuccess = (event) => {
          let cursor = event.target.result;
          if ( cursor ) {
            resolve(cursor.value)
          } else {
            resolve(false)
          }
        }
      } else resolve(false)
    }
  })
  //
  return p
}

//
async function remove_complete_if_exists(app_audio_key) {
  let p = new Promise((resolve,reject) => {
    let transaction = g_audio_db.transaction(AUDIO_SESSION_COMPLETE, "readwrite");
    let p_t = new Promise((resolve,reject) => {
      transaction.oncomplete = (ev) => {
        resolve(true)
        console.log("remove_complete_if_exists: transaction done")
      }
      transaction.onerror = (ev) => {
        console.log(ev)
        reject(false)
      }}
    )

    let userStore = transaction.objectStore(AUDIO_SESSION_COMPLETE);
    //
    let nameIndex = userStore.index('name');
    nameIndex.get(app_audio_key).onsuccess = async (evt) => {
      let value = evt.target.result;
      if ( value ) {
        let keyRangeValue = IDBKeyRange.only(value.name);
        nameIndex.openCursor(keyRangeValue).onsuccess = async (event) => {
          let cursor = event.target.result;
          if ( cursor ) {
            let request = cursor.delete();
            request.onsuccess = async () => {
              await p_t
              resolve(true)
            };
          } else {
            await p_t
            resolve(false)
          }
        }
      } else {
        await p_t
        resolve(false)
      }
    }
  })
  //
  return p
}


/*
  post_user_key
    see:  wv_ask_create_user(app_user_key)
    key_for_server = {      // don't send IV to the server
        'email' : user_email,
        'pub_key' : key_info.pk_str,  // store the public key as a hex string base64 encoded
        'server_id' : key_info.key_session_id,
        'priv' : key_info.wrapped_priv    // encrypted private key, if this one gets lost.
      }
*/
async function post_user_key(key_for_server) {   // key made on client
  //await wv_postData(SEND_WRAPPED_RECORDING_KEY,key_for_server)
}



// store_user_key
//    called when the user info is created by user_keys ... see wv_ask_create_user
//
function store_user_key(app_user_key,user_information) {
  let transaction = g_audio_db.transaction(AUDIO_USERID_STORE, "readwrite");
  let userStore = transaction.objectStore(AUDIO_USERID_STORE);
  user_information.app_key = app_user_key   // for DB retrieval
  userStore.put(user_information)           // information create by 
}

// wv_find_user 
//      on the user's device, store inforation that he needs to communicate with the servers
//
function wv_find_user(app_user_key) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: wv_find_user")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_USERID_STORE, "readwrite");
  let userStore = transaction.objectStore(AUDIO_USERID_STORE);
  //
  let found_user = null
  let request = userStore.openCursor();
  let p = new Promise( (resolve,reject) => {
    request.onsuccess = (event) => {
      var cursor = event.target.result;
      if ( cursor ) {
        let test_user = cursor.value
        let test = test_user.app_key == app_user_key
        if ( test ) {
          found_user = test_user
          resolve(found_user)       // make use of this user record  => back to main thread
        } else cursor.continue();
      } else {
        reject(found_user)    // could not find user ... throw exception => wv_ask_create_user
      }
    };
  })
  
  return p
}



// USER - local device user -- CREATE USER INFO
//    just one user per device.... make sure the user is there or use the existing user information...

function wv_ask_create_user(app_user_key) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: wv_ask_create_user")
    return;
  }
  //
  const value_holder = document.getElementById('wv-id-email')
  const machine_fld = document.getElementById('wv-id-machine')

  g_user_modal.showModal();
  //
  const modal = g_user_modal
  modal.addEventListener('close', async () => {
    let modal_value = modal.returnValue
    if ( modal_value === 'ready' ) {
      //
      let user_email = value_holder.value
      let machine_name = machine_fld.value
      //
      // exchange information with the server and set up a key for use in signing
      let key_info = await wv_user_keys(user_email)    // 
      //
      set_current_session_signing_key(key_info.priv_key)    // use it now for signing
      set_current_session_email(user_email)
      set_current_session_machine(machine_name)     // user later in creating a machine identifier
      //
      // STORE KEY INFORMATION OF USE LOCALLY
      let user_information = {
        'email' : user_email,
        'pub_key' : key_info.pk_str,  // store the public key
        'encrypted_key' : key_info.encrypted_key,  // store the private key
        'iv' : key_info.iv,
        'server_id' : key_info.key_session_id,
        'machine_name' : machine_name
      }
      store_user_key(app_user_key,user_information)
      //
      // ASK THE SERVER TO SAVE SOME INFORMATION ABOUT THIS FOR LATER RETRIEVAL
      let key_for_server = {      // don't send IV to the server
        'email' : user_email,
        'pub_key' : key_info.pk_str,  // store the public key
        'server_id' : key_info.key_session_id,
        'priv' : key_info.encrypted_key
      }
      post_user_key(key_for_server)       // possible to await
      // THE WORK THREAD WILL NEED TO KNOW ABOUT THE USER
      wv_user_info_to_worker(user_information)
      //
    } else {
    }
  });
  //
}


function update_audio_data(section_id,data_list,op_parameters) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: update_audio_data")
    return;
  }
  //
  let audioBlob = make_audio_blob(data_list)
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

  let update_list_elem_callback = (value,dbIndex) => {
    let keyRangeValue = IDBKeyRange.only(value.name);
    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
      var cursor = event.target.result;
      if ( cursor ) {
        let sessionObj = cursor.value
        if ( sessionObj.data[section_id] != null ) {
          let blob_url = URL.createObjectURL(audioBlob);
          sessionObj.data[section_id] = audioBlob
          // handle a case which should not happen
          if ( sessionObj.hashes[section_id] === undefined ) {
            sessionObj.hashes[section_id] = { 'op_history' : [] }
          }
          // update hash ops
          if ( op_parameters ) {
            let operation = {'op' : 'cut', "startX" :  op_parameters.startX, "w" : op_parameters.w, "samples" : op_parameters.samplePP }
            sessionObj.hashes[section_id].op_history.push(operation)
          } else {
            sessionObj.hashes[section_id].op_history.push({'op' : 'back'})
          }
          wv_secure('edit-update',audioBlob,section_id)
          //
          const request = cursor.update(sessionObj);
          request.onsuccess = async () => {
            update_audio_element(blob_url,section_id,audioBlob)  // visual rep
            await wv_secure_total_session(g_current_session_name)
          };
        }
        //
      }
    }
  }

  let not_found_callback = () => {
    warn(`The session ${sess_name} is not in the database`)
  }

  apply_find_audio_session(g_current_session_name, audioStore, update_list_elem_callback, not_found_callback)
}


function add_new_audio_session_to_db(audioStore,application_op) {
  let sess_loc_str = JSON.stringify(g_wv_current_locaion)
  //
  let sessionObj = {
      'name' : g_current_session_name,
      'sess_date_time' : '' + Date.now(),
      'sess_geo_location' : sess_loc_str,
      'data' : { },
      'original_chunks' : { },      // base64 encoded
      'hashes' : { },
      'edit_order' : [],            // a list of id's
      'locations' : [sess_loc_str]
    }
    //
    if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
      application_op(sessionObj)
    }
    let request = audioStore.add(sessionObj);
    return request
}


// assuming there is an array that has been collected
// each element will correspond to a resulting hash
// The hashes are sent to the server and can be reconstructed later
// but only if the chunk array is still available in its original form
async function wv_backup_audio_chunks_for_verification(section_id,audioChunksArray) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: wv_backup_audio_chunks_for_verification")
    return;
  }
  //
  let converted_chunks = []
  let n = audioChunksArray.length
  for ( let i = 0; i < n; i++ ) {
    let chunk = audioChunksArray[i]
    let storable = await blobToBase64(chunk)
    converted_chunks.push(storable)
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

  //
  let add_elem_original_chunks_callback = (value,dbIndex) => {
    let keyRangeValue = IDBKeyRange.only(value.name);
    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
      var cursor = event.target.result;
      if ( cursor ) {
        let sessionObj = cursor.value
        sessionObj.original_chunks[section_id] = converted_chunks
          const request = cursor.update(sessionObj);
          request.onsuccess = async () => {
            await wv_secure_total_session(g_current_session_name)
          };

      }
    }
  }
    //
    let not_found_callback = () => {
      console.log("wv_backup_audio_chunks_for_verification: no audio for current session")
    }
    //
    apply_find_audio_session(g_current_session_name, audioStore, add_elem_original_chunks_callback, not_found_callback)
 }



function add_audio_data(audioBlob,section_id) {

  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: add_audio_data")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

  let update_list_callback = (value,dbIndex) => {
    let keyRangeValue = IDBKeyRange.only(value.name);
    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
      var cursor = event.target.result;
      if ( cursor ) {
        let sessionObj = cursor.value
        let blob_url = URL.createObjectURL(audioBlob);
        // map_id = section_id
        sessionObj.data[section_id] = audioBlob
        if ( sessionObj.hashes[section_id] === undefined ) {
          sessionObj.hashes[section_id] = {}
        }
        if ( sessionObj.hashes[section_id].op_history === undefined ) {
          sessionObj.hashes[section_id].op_history = []
        }
        sessionObj.edit_order.push(section_id)
        // 
        let geo_update = JSON.stringify(g_wv_current_locaion)
        sessionObj.locations.push(geo_update)
        //
        const request = cursor.update(sessionObj);
        request.onsuccess = async () => {
          add_audio_element(blob_url,section_id,audioBlob,section_id)  // visual rep
          await wv_secure_total_session(g_current_session_name)
        };
        //
      }
    }
  }

  let add_new_callback = () => {
    let blob_url = URL.createObjectURL(audioBlob);
    //
    let application_op = (sessionObj) => {
      sessionObj.data[section_id] = audioBlob   // JSON.stringify(audioBlob)
      if ( sessionObj.hashes[section_id] === undefined ) {
          sessionObj.hashes[section_id] = {}
      }
      sessionObj.hashes[section_id].op_history = []
    } 
    //
    let request = add_new_audio_session_to_db(audioStore,application_op)
    if ( request ) {
      request.onsuccess = function(event) {
        sessionObj.edit_order.push(section_id)
        add_audio_element(blob_url,section_id,audioBlob)  // visual rep
      };
    }
    //
  }

  apply_find_audio_session(g_current_session_name, audioStore, update_list_callback, add_new_callback)
  //
}


async function wv_install_transferred_session(session_object) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: wv_install_transferred_session")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
  //
  let request = audioStore.put(session_object)
  request.onsuccess = (ev) => {
    let rsult = event.target.result
    //
    let sess_name = session_object.name
    add_in_new_session(sess_name)
  }
  //
}


async function get_audio_data(sess_name) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: get_audio_data")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
  //
  let p = new Promise((resolve,reject) => {
    //
    let get_elem_callback = (value,dbIndex) => {
      let keyRangeValue = IDBKeyRange.only(value.name);
      dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          let sessionObj = cursor.value
          resolve(sessionObj)
        }
      }
    }
    //
    let not_found_callback = () => {
      reject(null)
    }
    //
    apply_find_audio_session(sess_name, audioStore, get_elem_callback, not_found_callback)
  })
  //
  return p
}


function remove_audio_data(audio_key) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: remove_audio_data")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

  let remove_from_list_callback = (value,dbIndex) => {
    let keyRangeValue = IDBKeyRange.only(value.name);
    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
      var cursor = event.target.result;
      if ( cursor ) {
        let sessionObj = cursor.value
        delete sessionObj.data[audio_key]
        //
        const request = cursor.update(sessionObj);
        request.onsuccess = async () => {
          //  item has been removed
          console.log(`deleted ${audio_key}`)
          await wv_secure_total_session(g_current_session_name)
        };
        //
      }
    }
  }

  let not_found_callback = () => {
    warn(`The session ${sess_name} is not in the database`)
  }

  apply_find_audio_session(g_current_session_name, audioStore, remove_from_list_callback, not_found_callback)

}

function is_new_name(name) {
  if ( g_session_name_list.indexOf(name) >= 0 ) return(false)
  return(true)
}

function load_name_list() {
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readonly");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
  //
  g_session_name_list = []
  var myIndex = audioStore.index('name');
  myIndex.openCursor().onsuccess = (event) => {
    var cursor = event.target.result;
    if(cursor) {
      g_session_name_list.push(cursor.value.name)
      cursor.continue();
    } else {
      update_session_name_selections(g_current_session_name,g_session_name_list)
    }
  };
  //
}

function update_session_name_selections(sess_name,name_list) {
  let session_options = name_list.map(name => {
    let el_html = `<option value='${name}'>${name}</option>`
    return(el_html)
  })

  let no_option = `<option value="none">no selection</option>`
  session_options.unshift(no_option)
  let options = session_options.join('\n')
  let sessNameSel = document.getElementById('sess-names')
  if ( sessNameSel ) {
    sessNameSel.innerHTML = options
    sessNameSel.value = sess_name
  }
  let sess_name_el = document.getElementById('show-session-name')
  if ( sess_name_el ) sess_name_el.innerHTML = (sess_name === 'none') ? '<span style="color:orange">select or create a session</span>' : sess_name
}

function warn(str) {
  //
}

function add_in_new_session(name) {
  let sess_name_el = document.getElementById('show-session-name')
  if ( sess_name_el ) {
    g_current_session_name = name
    g_session_name_list.push(name)
    sess_name_el.innerHTML = name
    g_recordButton.removeAttribute('disabled');
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
    add_new_audio_session_to_db(audioStore)
    //
    clear_play_list()
    let sess_op_el = document.getElementById('delete-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "visible"
    }

    update_session_name_selections(g_current_session_name,g_session_name_list)
  }
}

function ask_user_session() {
  let proceed = confirm("Start a new session?")
  if ( proceed ) {
    let name = prompt("Name this session:", "new session");
    let new_name = is_new_name(name)
    if ( new_name ) {
      add_in_new_session(name)
    } else {
      warn("Session already exists. Do you want to edit it?")
    }
  }
}


async function choose_edit_user_session(name) {
  //
  if ( g_current_session_name !== 'none' ) {
    await wv_secure_total_session(g_current_session_name)
  }
  //
  g_save_up_audio_elements = {}
  //
  if ( name === 'none' ) {
    let sess_name_el = document.getElementById('show-session-name')
    if ( sess_name_el ) {
      g_current_session_name = 'none'
      sess_name_el.innerHTML = '<span style="color:orange">select or create a session</span>'

      g_recordButton.setAttribute('disabled', true);
      g_stopButton.setAttribute('disabled', true);
      g_playButton.setAttribute('disabled', true);
      g_saveButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      clear_play_list()
      let sess_op_el = null
      sess_op_el = document.getElementById('send-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "hidden"
      }
      sess_op_el = document.getElementById('delete-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "hidden"
      }
    }
  } else {
    let sess_name_el = document.getElementById('show-session-name')
    if ( sess_name_el ) {
      g_current_session_name = name
      sess_name_el.innerHTML = name
      g_recordButton.removeAttribute('disabled');
      g_stopButton.setAttribute('disabled', true);
      g_playButton.setAttribute('disabled', true);
      g_saveButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      //
      clear_play_list()
      let sess_op_el = null
      sess_op_el = document.getElementById('send-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "inherit"
      }
      sess_op_el = document.getElementById('delete-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "inherit"
      }
      populate_play_list(g_current_session_name)
    }
  }
  wv_change_session_name()
}

function edit_user_session(event) {
  let sessNameSel = document.getElementById('sess-names')
  choose_edit_user_session(sessNameSel.value)
}


function delete_session() {
  if ( g_current_session_name !== 'none ') {
    let sess_name = g_current_session_name
    if ( g_audio_db === null ) {
      console.log("db not initialized :: delete_session")
      return;
    }
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

    let delete_from_list_callback = (value,dbIndex) => {
      let sessionObj = value
      let keyRangeValue = IDBKeyRange.only(value.name);
      dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          var request = cursor.delete();
          request.onsuccess = () => {
            g_current_session_name = 'none'
            load_name_list()
            choose_edit_user_session(g_current_session_name)
          };
        }
      }
    }

    let not_found_callback = () => {
      warn(`The session ${sess_name} is not in the database`)
    }

    apply_find_audio_session(sess_name, audioStore, delete_from_list_callback, not_found_callback)    
  }
}


function wv_reset_audio_sections_order(map_ids) {
  if ( g_current_session_name !== 'none ') {
      let sess_name = g_current_session_name
      if ( g_audio_db === null ) {
        console.log("db not initialized :: delete_session")
        return;
      }
      //
      let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
      let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

      let reset_audio_ordering_callback = (value,dbIndex) => {
        let keyRangeValue = IDBKeyRange.only(value.name);
        dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
          var cursor = event.target.result;
          if ( cursor ) {
            let sessionObj = cursor.value
            sessionObj.edit_order = map_ids
            const request = cursor.update(sessionObj);
            request.onsuccess = async () => {
              await wv_secure_total_session(g_current_session_name)
            };
          }
        }
      }

      let not_found_callback = () => {
        warn(`The session ${sess_name} is not in the database`)
      }

      apply_find_audio_session(sess_name, audioStore, reset_audio_ordering_callback, not_found_callback)    
  }
}

  
// RECORDER
async function wv_init_recorder() {
  const stream = await navigator.mediaDevices.getUserMedia({ 'audio': true });
  g_app_recoder = new AppAudioRecorder(stream)
}

//
const sleep = time => new Promise(resolve => setTimeout(resolve, time));

function wv_initialize_global_buttons() {
  //
  g_recordButton.setAttribute('disabled', true);
  g_stopButton.setAttribute('disabled', true);
  g_playButton.setAttribute('disabled', true);
  g_saveButton.setAttribute('disabled', true);
  g_deleteButton.setAttribute('disabled', true);
  let sess_op_el = null
  sess_op_el = document.getElementById('send-session')
  if ( sess_op_el ) {
    sess_op_el.style.visibility = "hidden"
  }
  sess_op_el = document.getElementById('delete-session')
  if ( sess_op_el ) {
    sess_op_el.style.visibility = "hidden"
  }

  // RECORD
  g_recordButton.addEventListener('click', async () => {
    stop_geo_update()
    g_recordButton.setAttribute('disabled', true);
    g_stopButton.removeAttribute('disabled');
    g_playButton.setAttribute('disabled', true);
    g_saveButton.setAttribute('disabled', true);
    g_deleteButton.setAttribute('disabled', true);
    g_app_recoder.start();
  });

  // STOP RECORD
  g_stopButton.addEventListener('click', async () => {
    restart_geo_update()
    g_recordButton.removeAttribute('disabled');
    g_stopButton.setAttribute('disabled', true);
    g_playButton.removeAttribute('disabled');
    g_saveButton.removeAttribute('disabled');
    g_deleteButton.removeAttribute('disabled');
    g_app_recoder.stop();
  });

  // PLAY
  g_playButton.addEventListener('click', () => {
    stop_geo_update()
    g_app_recoder.play();
  });

  // DELETE
  g_deleteButton.addEventListener('click', async () => {
    g_saveButton.setAttribute('disabled', true);
    g_playButton.setAttribute('disabled', true);
    g_deleteButton.setAttribute('disabled', true);
    g_app_recoder.delete_last_recorderd_audio()
  })

  // SAVE
  g_saveButton.addEventListener('click', () => {
    g_app_recoder.add_current_data()
    let sess_op_el = document.getElementById('send-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "visible"
    }
  });

}


  function wv_rect_vertical_intersect_size(r1,r2) {
    //
    let y1_top = r1.top
    let y1_bot = r1.bottom
    //
    let y2_top = r2.top
    let y2_bot = r2.bottom
    if ( (y2_bot <= y1_top) || (y1_bot <= y2_top) ) return 0
    //
    if ( y1_top < y2_top ) {
      return(y1_bot - y2_top)  // increasing downward
    } else {
      return(y2_bot - y1_top)  // increasing downward
    }
  }

  g_audio_play_list_order = []
  function getIntersectedElement(rect) {
    if ( g_audio_play_list_order.length > 1 ) {
      let max_area = 0
      let area_owner = null
      g_audio_play_list_order.forEach(divEl => {
        let check_rect = divEl.getBoundingClientRect()
        let intersect_size = wv_rect_vertical_intersect_size(rect,check_rect)
        if ( intersect_size > max_area ) {
          max_area = intersect_size
          area_owner = divEl
        }
      })
      return area_owner
    }
    return false
  }

  function lst_remove(list,index) {
    list.splice(index,1)
  }

  function lst_insert_before(list,el,index) {
    list.splice(index,0,el)
  }


  function wv_reposition(srcEl,dstEl) {
    let i = 0;
    let n = g_audio_play_list_order.length
    let from = -1
    let to = -1
    while ( i < n ) {
      let tst_el = g_audio_play_list_order[i]
      if ( tst_el == srcEl ) from = i
      if ( tst_el == dstEl ) to = i
      if ( (from != -1) && (to != -1) ) break
      i++
    }
    if ( ( from != -1 )&& ( to != -1 ) && ( from !== to ) ) {
      // not a swap...
      // swap the two elements according to their position in the childNodes of the parent
      let p_node = srcEl.parentNode
      if ( p_node ) {
        if ( from > to ) {
          lst_remove(g_audio_play_list_order,from)
          lst_insert_before(g_audio_play_list_order,srcEl,to)
          //
          p_node.insertBefore(srcEl,dstEl)
        } else if ( from < to ) {
          lst_remove(g_audio_play_list_order,from)
          lst_insert_before(g_audio_play_list_order,srcEl,to)
          //    
          let dst_follow_node = dstEl.nextSibling
          if ( dst_follow_node ) {
            p_node.insertBefore(srcEl,dst_follow_node)
          } else {
            p_node.appendChild(srcEl)
          } 
        }
      }
      //
      if ( from !== to ) {
        let map_ids = g_audio_play_list_order.map(divEl => {
          let id = divEl.id
          id = id.replace('audio-div-','')
          return(id)
        })
        //
        wv_reset_audio_sections_order(map_ids)
      }
      //
    }

  }



  function wv_move_html_element(elem,track_source) {
    //
    if ( elem._tracker ) {
      elem.removeEventListener('mousemove',elem._tracker)
    }
    elem._tracker = (ev) => {
      let mover = elem;
      let y = ev.clientY;
      let delta_y = mover._app_mouse_y - ev.clientY;
      mover._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (mover.offsetTop - delta_y)
      // lower bound
      if ( new_y > 8 ) mover.style.top = new_y + "px";
    }
    window.addEventListener('mousemove',elem._tracker)
    track_source.addEventListener('mousemove',elem._tracker)
    //
    elem._releaser = (ev) => {
      track_source.removeEventListener('mousemove',elem._tracker)
      window.removeEventListener('mousemove',elem._tracker)
      window.removeEventListener('mouseup',elem._releaser)
      elem._releaser = null
      elem._tracker = null
      //
      let divEl = elem._source
      divEl._ghost = false
      elem._source = false
      divEl._moving_audio_box = 0
      divEl._dragging = false
      //
      let y = ev.clientY;
      let rect = elem.getBoundingClientRect();
      elem.style.visibility = 'hidden'
      elem.style.display = 'none'
      //
      let overEl = getIntersectedElement(rect)
      if ( overEl && (overEl !== track_source) ) {
        let ydiff = elem._app_mouse_y - y;
        wv_reposition(divEl,overEl)
      }
      //
    }
    window.addEventListener('mouseup',elem._releaser)
  }

  
  function add_audio_playback_box_responsiveness(divEl) {
    //
    g_audio_play_list_order.push(divEl)
    //
    divEl._wait_to_drag = null
    //
    divEl.addEventListener('mousedown',(ev) => {
      if ( divEl !== ev.target ) return;
      divEl._wait_to_drag = setTimeout(() => {
        clearTimeout(divEl._wait_to_drag)
        divEl._wait_to_drag = null
        //
        let outliner = document.getElementById('audioBoxGhost')
        outliner.style.position = "absolute"
        outliner.style.zIndex = 1000
        let d_rect = divEl.getBoundingClientRect()
        outliner.style.top = d_rect.top + "px"
        outliner.style.left = d_rect.left + "px"
        outliner.style.width = d_rect.width + "px"
        outliner.style.height = d_rect.height + "px"
        outliner._source = divEl
        divEl._ghost = outliner
        outliner.style.display = 'block'
        outliner.style.visibility = "inherit"
        let y = ev.clientY;
        outliner._app_mouse_y = y
        //---
        wv_move_html_element(outliner,divEl)
        //--
      },350)
    })
    //
    let quic_hit = (ev) => {
      if ( divEl._wait_to_drag !== null ) {
        clearTimeout(divEl._wait_to_drag)
        divEl._wait_to_drag = null
      }
      window.removeEventListener('mouseup',quic_hit)
    }
    divEl.addEventListener('mouseup',quic_hit)
  }



function update_audio_element(audio_el_url,index,audioBlob) {
  if ( index === undefined ) return
  else {
    let audioElement = document.getElementById(`audio-player-${index}`)
    if ( audioElement ) {
      audioElement.src = audio_el_url;
      audioElement.setAttribute('data-audio-filename', audio_el_url);
      audioElement.pause()
      audioElement.load()
      let divEl = document.getElementById(`audio-div-${index}`)
      if ( divEl ) {
        divEl._ref_audio_data = audioBlob
      }
    }
  }
}


function add_audio_element(audio_el_url,index,audioBlob,section_id) {
  if ( index === undefined ) index = uuidv4()
  let audioElement = document.createElement('audio');
  audioElement.src = audio_el_url;
  audioElement.setAttribute('data-audio-filename', audio_el_url);
  audioElement.setAttribute('controls', true);
  audioElement.className = "audio-playback"
  audioElement.id = `audio-player-${index}`
  g_save_up_audio_elements[index] = audioElement
  // ontimeupdate
  // add a playback track
  let divEl = document.createElement('div')
  divEl.id = `audio-div-${index}`
  divEl._ref_audio_data = audioBlob
  divEl.className = "playback-div"
  add_audio_playback_box_responsiveness(divEl)
  let checkEl = document.createElement('input')
  checkEl.type = "checkbox";
  checkEl.name = `audioSections`;
  checkEl.className = "check_audio_element"
  checkEl.value = "";
  checkEl.id = `audio-cbox-${index}`;
  divEl.appendChild(checkEl)
  divEl.appendChild(audioElement)
  // add the element
  savedAudioMessagesContainer.appendChild(divEl);
}


function clear_play_list() {
    g_audio_play_list_order = []
  if ( savedAudioMessagesContainer ) {
    let wave_keys = Object.keys(g_wave_open_editors)
    wave_keys.forEach( wave_name => { remove_wave_editor(wave_name) } )
    savedAudioMessagesContainer.innerHTML = ""
  }
}


function populate_play_list(sess_name) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: populate_play_list")
    return;
  }
  //
  let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readonly");
  let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
  //
  let update_list_callback = (value) => {
    let sessionObj = value
    let blob_map = sessionObj.data
      let ordering = sessionObj.edit_order
      ordering = ordering.map(bid => {
        if ( bid.indexOf('audio-div-') === 0 ) {
          return bid.replace('audio-div-','')
        } else {
          return bid
        }
      })
      ordering.forEach(blob_id => {
        let audioBlob = blob_map[blob_id]
        let blob_url = URL.createObjectURL(audioBlob)
        add_audio_element(blob_url,blob_id,audioBlob)
      })
  }

  let not_found_callback = () => {
    warn(`The session ${sess_name} is not in the database`)
  }

  apply_find_audio_session(sess_name, audioStore, update_list_callback, not_found_callback)

};

// WAVE EDITOR FUNCIONALITY


function draw_h_line(ctx, x, y, width, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo((x + width), y);
  ctx.stroke();
}

function draw_v_line(ctx, x, y, height, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x, (y + height));
  ctx.stroke();
}


function draw_short_line(ctx, x0, y0, x1, y1, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.stroke();
}

function draw_line_chart(ctx,x0,y0,data,offset,n,thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.closePath();
  //
  let x = x0
  ctx.moveTo(x,y0);
  for ( let i = 0; i < n; (i++,x++) ) {
    ctx.lineTo(x, -data[i+offset]);    // canvas is upside down
  }
  ctx.stroke();
}

function draw_seconds(ctx,x,y,color,txt) {
  ctx.lineWidth = 2; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.font = '22px serif';
  let secs_txt = txt + " secs"
  ctx.fillText(secs_txt, x, y);
}

function wv_clear_selection(player_info) {
  if ( player_info.save_selection.startX !== undefined ) {
    let ctx = player_info.graph
    let saved_comp = ctx.globalCompositeOperation 
    let rect = player_info.save_selection
    ctx.globalCompositeOperation = 'xor'
    ctx.fillStyle = "#000000";
    ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
    ctx.globalCompositeOperation = saved_comp
    player_info.save_selection = {}
  }
}


const getBlobData = (wave_name) => {
  let player_div = document.getElementById(`audio-div-${wave_name}`)
  let audio_blob = player_div._ref_audio_data
  return audio_blob
}

async function get_wave_data(wave_name,channels,blob_fetcher) {  // sample_ratio up or down sample
  let audio_blob = blob_fetcher ? blob_fetcher(wave_name) : getBlobData(wave_name)
  const audioContext = new AudioContext();
  // audio blob contains blob data
  let arrayBuffer = await audio_blob.arrayBuffer();
  let audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
  if ( (channels === undefined) || (channels === 1) ) {
    let rawData = audioBuffer.getChannelData(0);
    return rawData      
  } else {
    let rawData = []
    let nchan = Math.min(audioBuffer.numberOfChannels,channels)
    for ( let i = 0; i < nchan; i++ ) {
      rawData.push(audioBuffer.getChannelData(i))
    }
    return(rawData)
  }
}

function get_wave_seconds(wave_name) {  // use the element
  let audioElement = g_save_up_audio_elements[wave_name]
  if ( audioElement ) {
    return(`${audioElement.duration}`)
  }
  return 'NaN'
}

//
// spp -- samples per pixel
function reduceAudioPeak(data, spp, scroll, width) {
  if ( spp <= 1 ) return(data)
  //
  let drawData = new Array(width);
  let startSample = scroll * spp; 
  // For each pixel in draw area
  for ( let i = 0; i < width; i++ ) {
      let min = 0; // minimum value in sample range
      let max = 0; // maximum value in sample range
      let k = startSample + (i * spp);

      // Iterate over the sample range for this pixel (spp) 
      // and find the min and max values. 
      let avg = 0.0
      for ( let j = 0; j < spp; (j++,k++) ) {
         if ( k < data.length ) {
             let val = data[k];
             avg += val
         }
      }
      avg = avg/spp

      drawData[i] = avg;
  }
  return drawData;
}

  
function draw_wave(data,ctx,W,h,dataSecs) {
    // Set up the canvas
    ctx.clearRect(0,-h,W,(2*h))
    draw_h_line(ctx, 0, 0, W, 2, '#009')
    let offset = ZERO_AXIS_OFFSET
    draw_v_line(ctx, offset, -h, (2*h), 2, '#9999A9')
    //
    // size data to visible
    let n_pixels = (W - offset)
    let samples_per_pixel = Math.ceil(data.length/n_pixels)
    let dmax = Math.max(...data)
    let section_start = 0 //data.indexOf(dmax) - 200
    let dmin = Math.abs(Math.min(...data))
    dmax = Math.max(dmin,dmax)
    let factor = WAVE_DISPLAY_MAX/dmin
    data = data.map(datum => datum*factor)
    let draw_data = reduceAudioPeak(data, samples_per_pixel, 0, n_pixels)
    //
    draw_line_chart(ctx, 10, 0, draw_data, section_start, n_pixels, 1, '#000')
    //
    let fsecs = parseFloat(dataSecs)
    fsecs = fsecs.toFixed(3)
    //
    if ( dataSecs ) draw_seconds(ctx,15,h,'#000',`${fsecs}`)
  }


function update_play_marker(ctx,play_info,percent) {
  let last_tick = play_info.where_ticker
  let offset = ZERO_AXIS_OFFSET
  let width = play_info.width - offset
  let where_now = Math.round(width*percent) + offset
  play_info.where_ticker = where_now
  //
  let saved_comp = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = 'xor'
  ctx.fillStyle = "#000000";
  ctx.fillRect(last_tick,-play_info.height,2,(2*play_info.height));
  ctx.fillRect(where_now,-play_info.height,2,(2*play_info.height));
  ctx.globalCompositeOperation = saved_comp
}

function isElementVisible(el,topOffset,leftOffset) {
  let rect     = el.getBoundingClientRect(),
      vWidth   = window.innerWidth || document.documentElement.clientWidth,
      vHeight  = window.innerHeight || document.documentElement.clientHeight,
      efp      = function (x, y) { return document.elementFromPoint(x, y) };     

  // Return false if it's not in the viewport
  if (rect.right < 0 || rect.bottom < 0 
          || rect.left > vWidth || rect.top > vHeight)
      return false;

  // Return true if any of its four corners are visible
  let rect_top = rect.top + (topOffset ? topOffset : 0)
  let rect_left = rect.left + (leftOffset ? topOffset : 0)
  return (
        el.contains(efp(rect_left,  rect_top))
    ||  el.contains(efp(rect.right, rect_top))
    ||  el.contains(efp(rect.right, rect.bottom))
    ||  el.contains(efp(rect_left,  rect.bottom))
  );
}

async function open_wave_editor(wave_name) {
  let el = g_wave_open_editors[wave_name]
  if ( el !== undefined ) {
    let container = g_wave_open_editors[wave_name].display
    if ( !isElementVisible(container,20,20) ) {
      container.style.top = "20px"
      container.style.left = "20px"
    }
    switch_z(container)
    return
  }
  let div = document.getElementById('wave-graph-tmplt')
  let clone = div.cloneNode(true); // true means clone all childNodes and all event handlers
  clone.id = wave_name;
  document.body.appendChild(clone);
  clone.style.display = 'block'
  clone.style.display = 'visible'
  clone._app_dragging = false
  if ( div._app_zIndex === undefined ) div._app_zIndex = 500
  else  div._app_zIndex++
  clone.style.zIndex = div._app_zIndex
  clone._app_zIndex = div._app_zIndex
  console.log(clone.style.zIndex)
  //
  let canvas = clone.getElementsByTagName('canvas')[0];
  //
  const dpr = window.devicePixelRatio || 1;
  const padding = 20;
  canvas.width = canvas.offsetWidth * dpr;
  canvas.height = (canvas.offsetHeight + padding * 2) * dpr;
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  ctx.translate(0, canvas.offsetHeight / 2 + padding); // Set Y = 0 to be in the middle of the canvas
  //
  let audio_el = document.getElementById(`audio-player-${wave_name}`)
  if ( audio_el ) {
    audio_el.ontimeupdate = (event) => {
      let aud_el = event.target
      if ( aud_el ) {
        let play_info = g_wave_open_editors[wave_name]
        if ( play_info ) {
          let play_time = aud_el.currentTime
          let duration = aud_el.duration
          let percent = play_time/duration
          let ctx = play_info.graph
          let prev_offset = play_info.where_ticker
          update_play_marker(ctx,play_info,percent)
        }
      }
    }
  }
  //
  g_wave_open_editors[wave_name] = { 
    'display' : clone, 
    'canvas' : canvas, 
    'graph' : ctx, 
    'player' : audio_el, 
    'where_ticker' : 0, 
    'width' : canvas.offsetWidth,
    'height' : canvas.height,
    'selection_rect' : {},
    'save_selection' : {},
    'ops_undo_stack' : [],
    'dragging' : false
  }
  //
  let data = await get_wave_data(wave_name)
  let W = canvas.offsetWidth
  let h = canvas.height
  let rec_seconds = get_wave_seconds(wave_name)
  //
  draw_wave(data,ctx,W,h,rec_seconds) 
  //
  // Editor Drawing Events
  let player_info = g_wave_open_editors[wave_name]
  let wv_edit_mouseDown = (e) => {
    //
    wv_clear_selection(player_info)
    //
    player_info.selection_rect = {}
    let container = player_info.display
    player_info.selection_rect.startX = e.pageX - container.offsetLeft;
    player_info.selection_rect.startY = -player_info.height //e.pageY - canvas.offsetTop;
    player_info.selection_rect.h = (2*player_info.height)
    player_info.selection_rect.w = 0
    player_info.dragging = true;
  }
  let wv_edit_mouseUp = (e) => { player_info.dragging = false }
  let wv_edit_mouseMove = (e) => {
    if ( player_info.dragging ) {
      let canvas = player_info.canvas
      let saved_comp = ctx.globalCompositeOperation
      let rect = player_info.selection_rect
      ctx.globalCompositeOperation = 'xor'
      ctx.fillStyle = "#000000";
      ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      let container = player_info.display
      rect.w = (e.pageX - container.offsetLeft) - rect.startX;
      ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      ctx.globalCompositeOperation = saved_comp
      player_info.save_selection.startX = rect.startX
      player_info.save_selection.startY = rect.startY
      player_info.save_selection.w = rect.w
      player_info.save_selection.h = rect.h
    }
  }
  canvas.addEventListener('mousedown', wv_edit_mouseDown, false);
  canvas.addEventListener('mouseup', wv_edit_mouseUp, false);
  canvas.addEventListener('mousemove', wv_edit_mouseMove, false);
}

//  g_wave_open_editors[wave_name] = { 'display' : clone, 'graph' : ctx }
//
//
function remove_wave_editor(wave_name) {
  let editor_data = g_wave_open_editors[wave_name]
  if ( editor_data ) {
    let container = editor_data.display
    find_new_z(wave_name,container,g_wave_open_editors)
    if ( container ) container.remove()
    delete  g_wave_open_editors[wave_name]
  }
}
//
function wv_closer_editor(e) {
  e = e || window.event;
  e.preventDefault();

  let t = e.target
  if ( t ) {
    try {
      g_wave_current_container = null
      let container = t.parentNode.parentNode
      let wave_name = container.id
      remove_wave_editor(wave_name)
    } catch(e) {
    }
  }
}

// //
// //
function wv_zoom_in(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {

  }
}

function wv_zoom_in(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {

  }
}

function wv_scroll_left(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {

  }
}

function wv_scroll_right(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {
    
  }
}

//  wv_cut_data
function wv_cut_data(data,selection_rect,samples_per_pixel) {
  let start = (selection_rect.startX)*samples_per_pixel
  let end = (selection_rect.w)*samples_per_pixel + start
  let tail_data = data.subarray(end)
  data.set(tail_data,start)
  let display_data = data.slice(0,(start + tail_data.length))
  return(display_data)
}

async function wv_cut_selection(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode.parentNode
  if ( container ) {
    let wave_name = container.id
    let player_info = g_wave_open_editors[wave_name]
    //
    let canvas = player_info.canvas
    if ( canvas && (player_info.save_selection.startX !== undefined) ) {
      if ( player_info.save_selection.w <= 0 ) {   // turn the selection around only when it is backwards
        if ( player_info.save_selection.w === 0 ) return
        else {
          let w = player_info.save_selection.w
          let sx = player_info.save_selection.startX + w
          player_info.save_selection.w = -w
          player_info.save_selection.startX = sx
        }
      }
      //
      let data_list = await get_wave_data(wave_name,2)
      player_info.ops_undo_stack.push({ 'op' : 'cut',
                                              'data' : new Float32Array(data_list[0]), 
                                              'data2' : new Float32Array(data_list[1]) })
      let W = canvas.offsetWidth
      let h = canvas.height
      let n_pixels = (W - ZERO_AXIS_OFFSET)
      let samples_per_pixel = Math.ceil(data_list[0].length/n_pixels)
      let display_data = wv_cut_data(data_list[0],player_info.save_selection,samples_per_pixel)
      let c2_data = null
      if ( data_list.length > 1 ) {
        c2_data = wv_cut_data(data_list[1],player_info.save_selection,samples_per_pixel)
      } else {
        c2_data = new Float32Array(display_data)
      }
      //
      wv_clear_selection(player_info)
      let ctx = player_info.graph
      let sample_rate = g_audioContext.sampleRate
      let rec_seconds = (1.0*display_data.length)/sample_rate
      draw_wave(display_data,ctx,W,h,rec_seconds)
      //
      data_list = [display_data,c2_data]
      player_info.save_selection.samplePP = samples_per_pixel
      update_audio_data(wave_name,data_list,player_info.save_selection)
    }
  }
}
/*
function wv_save_current_buffer(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {
    
  }
}
*/
function wv_restore_selection(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode.parentNode
  if ( container ) {
    let wave_name = container.id
    let player_info = g_wave_open_editors[wave_name]
    // // //
    if (  player_info.ops_undo_stack.length ) {
      let undo_op = player_info.ops_undo_stack.pop()
      let data = null
      if ( undo_op.op === 'cut' ) {
        let canvas = player_info.canvas
        if ( canvas ) {
          data = undo_op.data
          //
          let W = canvas.offsetWidth
          let h = canvas.height
          let ctx = player_info.graph
          let sample_rate = g_audioContext.sampleRate
          let rec_seconds = (1.0*data.length)/sample_rate
          draw_wave(data,ctx,W,h,rec_seconds)
          //
          let data2 = undo_op.data2
          let data_list = [data,data2]
          update_audio_data(wave_name,data_list,false)
        }
      }
    }
  }
}
// // //

function switch_z(container,prev_c) {
  let source_c = ( prev_c === undefined ) ? g_wave_current_container : prev_c
  //
  if ( source_c !== null ) {
    if ( container.className == 'wave-graph-container' ) {
      if ( container !== source_c ) {
        let z = container._app_zIndex
        if ( z !== undefined ) {
          container._app_zIndex = source_c._app_zIndex
          container.style.zIndex = source_c._app_zIndex
          source_c.style.zIndex = z
          source_c._app_zIndex = z
        }
      }
    }
  }
}

function find_new_z(wave_name,container,open_containers) {
  let c_names = Object.keys(open_containers)
  if ( c_names.length > 1 ) {
    let n = c_names.length
    let max_z = -1
    let switcher = null
    for ( let i = 0; i < n; i++ ) {
      let name = c_names[i]
      if ( name !== wave_name ) {
        let oc = open_containers[name].display
        let z = oc._app_zIndex
        if ( z > max_z ) {
          max_z = z
          switcher = oc
        }
      }
    }
    if ( switcher ) {
      switch_z(switcher,container)
      g_wave_current_container = switcher
    }
  }
}

//
function wv_capture_cursor(ev,el_depth)  {
  ev = ev || window.event;
  //ev.preventDefault();

  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      switch_z(container)
      let x = ev.clientX;
      let y = ev.clientY; 
      container._app_mouse_x = x
      container._app_mouse_y = y
      container._app_dragging = true
      if ( container.className == 'wave-graph-container' ) {
        g_wave_current_container = container
        document.addEventListener('mouseup',(ev) => {
          if ( g_wave_current_container != null ) {
            g_wave_current_container._app_dragging = false
          }
        })
      }
    }
  }
}
//
function wv_release_captured_cursor(ev,check_limits,el_depth) {
  ev = ev || window.event;
  if ( !check_limits ) ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      if ( check_limits ) {
        let check_y = Math.abs(container.offsetTop - ev.clientY)
        let check_x = Math.abs(container._app_mouse_x - ev.clientX)
        let dist = Math.sqrt((0.25)*check_y*check_y + check_x*check_x)
        if ( dist < WV_CONST_MOUSE_DRAG_DIST_TOLERANCE ) return
      }
      container._app_dragging = false
    }
  }
}
//
function wv_check_cursor_entry(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      if ( ev.buttons === 0 ) {
        container._app_dragging = false
      }
    }
  }
}
//
function wv_track_cursor_out(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container && container._app_dragging ) {
      // calculate the new cursor position:
      let prev_x = container._app_mouse_x - ev.clientX;
      let prev_y = container._app_mouse_y - ev.clientY;
      container._app_mouse_x = ev.clientX;
      container._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (container.offsetTop - prev_y)
      let new_x = (container.offsetLeft - prev_x)
      if ( new_y > 8 ) container.style.top = new_y + "px";
      if ( new_x > 8 ) container.style.left = new_x + "px";
    }
  }
}
//
function wv_track_cursor(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container && container._app_dragging ) {
      // calculate the new cursor position:
      let prev_x = container._app_mouse_x - ev.clientX;
      let prev_y = container._app_mouse_y - ev.clientY;
      container._app_mouse_x = ev.clientX;
      container._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (container.offsetTop - prev_y)
      let new_x = (container.offsetLeft - prev_x)
      if ( new_y > 8 ) container.style.top = new_y + "px";
      if ( new_x > 8 ) container.style.left = new_x + "px";
    }
  }
}
//
function wv_edit_checked() {
  var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
  checkedBoxes.forEach(cbox => {
    let wave_name = cbox.id.replace('audio-cbox-','')
    open_wave_editor(wave_name)
  })
}
// 
function wv_delete_checked() {
  var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
  checkedBoxes.forEach(cbox => {
    let cbox_id = cbox.id
    let container_id = cbox_id.replace('cbox','div')
    let container = document.getElementById(container_id)
    if ( container ) {
      let parent = savedAudioMessagesContainer //container.parentNode()
      parent.removeChild(container)
      remove_audio_data(cbox_id.replace('audio-cbox-',''))
    }
  })
}

// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----

function wv_user_info_to_worker(user_info) {
  try {
    let message = {
      'type' : 'init',
      'user' : user_info,
      'iv' : hex_toByteArray(user_info.iv)
    }
    if ( user_info.machine_name === undefined ) {
      user_info.machine_name = g_current_session_machine_name
    }
    delete user_info.iv
    g_ownership_worker.postMessage(message) //,[message.priv,message.iv]
  } catch (e) {
    console.log(e)
    return false
  }
  return true
}

function wv_active_key_to_worker(unwrapped_aes) {
  try {
    let message = {
      'type' : 'a_key',
      'key' : unwrapped_aes
    }
    g_ownership_worker.postMessage(message)
  } catch (e) {
    console.log(e)
    return false
  }
  return true
}

function wv_prep_secure_relay(data_chunk) {
  // relay to worker
  let message = {
    'type' : 'chunk',
    'chunk' : data_chunk,
    'sess_name' : g_current_session_name
  }
  g_ownership_worker.postMessage(message) // ,[data_chunk]
}

function wv_secure(op,audioBlob,id_param) {  // edit-update, end-recording
  // relay to worker
  let message = {
    'type' : 'benchmark',
    'blob' : audioBlob,
    'op' : op,
    'blob_id' : id_param
  }
  g_ownership_worker.postMessage(message)
}

async function wv_secure_total_session(sess_name) {
  try {
    let sessionObj = await get_audio_data(sess_name)
    let complete_name = sess_name + "-complete"
    await make_complete_session_record(complete_name,sessionObj,g_preferred_download_format)
    let message = {
      'type' : 'storage',
      'sess_id' : complete_name,
      'ext' : ext_from_download_format(g_preferred_download_format)
    }
    // get the session data and store it
    g_ownership_worker.postMessage(message)  // just send the key for DB retrieval
    //
  } catch (e) {
  }
}

async function wv_move_session(sess_name) {
  try {
    let sessionObj = await get_audio_data(sess_name)
    let message = {
      'type' : 'device-move',
      'sess_id' : sess_name
    }
    // get the session data and store it
    g_ownership_worker.postMessage(message)  // just send the key for DB retrieval
    //
  } catch (e) {
  }
}

//
function wv_change_session_name() {  // tell worker what session is being edited
  let message = {
    'type' : 'session',
    'sess_name' : g_current_session_name
  }
  g_ownership_worker.postMessage(message)
}

//
function wv_update_geo_location(location) {
  let message = {
    'type' : 'geolocation',
    'geo_location' : location
  }
  g_ownership_worker.postMessage(message)
}



//  download_audio_session_record
//  -- present a dialog to a user for downloading the current session in some audio format that deterines ext
var downloader_url = null
async function download_audio_session_record(sess_name,downloadlink) {
  if ( !(downloadlink) ) return false
  let sess_name_cmplt = sess_name + '-complete'
  let data = await get_audio_key(sess_name_cmplt)
  if ( data ) {
    //
    let sess_blob = data.blob
    let barray = convertDataURIToBinary(sess_blob)
    //
    //let snd = new Audio(sess_blob)
    //snd.play()

    // //
    let contentType = g_preferred_download_format
    let file_data = new Blob([barray], {type: contentType});
    //
    //
    let f_url = URL.createObjectURL(file_data);

    if ( downloader_url !== null ) {
      URL.revokeObjectURL(downloader_url)
    }
    downloader_url = f_url
    downloadlink.href = f_url
    let ext = data.ext ? data.ext : "mp3"
    downloadlink.download = sess_name + '.' + ext;
    downloadlink.click();
    //
    return true
  }
  return false
}


// download verification data
// 
var verifier_downloader_url = null
async function download_verification_session_record(sess_name,downloadlink) {
  if ( !(downloadlink) ) return false
  let sess_name_cmplt = sess_name + '-complete'
  let data = await get_audio_key(sess_name_cmplt)
  if ( data ) {
    let all_verify_data = {
      "base_audio" : data,
      "session_info" : {}
    }
    let sessObj = await get_audio_data(sess_name)
    if ( sessObj ) {
      all_verify_data.session_info = sessObj
      //
      let f_url = URL.createObjectURL(all_verify_data);

      if ( verifier_downloader_url !== null ) {
        URL.revokeObjectURL(verifier_downloader_url)
      }
      verifier_downloader_url = f_url
      downloadlink.href = f_url
      let ext = data.ext ? data.ext : "json"
      downloadlink.download = sess_name + '.' + ext;
      downloadlink.click();
    }
  }
}




// // 
async function download_prompt() {
  let downloader = g_audio_download_modal
  let downloadlink = document.getElementById('wave-download-link')
  if ( downloader && downloadlink ) {
    downloadlink.innerHTML = `Download ${g_current_session_name}`
    if ( downloader.showModal ) downloader.showModal()
    else {
      downloader.style.visibility = 'visible'
      downloader.style.display = 'block'
    }
    let result = await download_audio_session_record(g_current_session_name,downloadlink)
    if ( result ) {
      // maybe send a copy to the server ???
    }
    if ( downloader.close ) downloader.close()
    else {
      downloader.style.visibility = 'hidden'
      downloader.style.display = 'none'
    }
  }
}


// // 
async function download_verification_prompt() {
  let downloader = g_verify_download_modal
  let downloadlink = document.getElementById('verification-download-link')
  if ( downloader && downloadlink ) {
    downloadlink.innerHTML = `Download ${g_current_session_name}`
    if ( downloader.showModal ) downloader.showModal()
    else {
      downloader.style.visibility = 'visible'
      downloader.style.display = 'block'
    }
    let result = await download_verification_session_record(g_current_session_name,downloadlink)
    if ( result ) {
      // maybe send a copy to the server ???
    }
    if ( downloader.close ) downloader.close()
    else {
      downloader.style.visibility = 'hidden'
      downloader.style.display = 'none'
    }
  }
}




function worker_status_view(status) {
  //
}

function worker_op_response(data) {
  //
}

// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----

async function request_transferred_session(email,sess_name) {
  let session_identification = {
        'email' : user_email,
        'sess_name' : sess_name
      }
  try {
    let session_data = await wv_postData(REQ_AUDIO_SESSION_TRANSFER,session_identification)
    if ( session_data && session_data.packed ) {
      let user_info = await wv_find_user(APP_USER_SINGLETON)
      let session_object = await wv_unpack_session_data(session_data.packed,user_info)
      await wv_install_transferred_session(session_object)
      alert(`The session ${sess_name} is now available for editing`)
    }
  } catch(e) {
  }
}


// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----

function wv_getLocation() {
  if (navigator.geolocation) {
    var x = document.getElementById("wv-geo-location");
    navigator.geolocation.watchPosition((position) => {  // watch position updates location at a system defined interval
      x.innerHTML = `${position.coords.latitude},${position.coords.longitude}`
      g_wv_current_locaion = { "latitude" : position.coords.latitude, "longitude" : position.coords.longitude }  // clone
      wv_update_geo_location(g_wv_current_locaion)
    });
  } else { 
    alert("Geolocation is not supported by this browser.");
  }
}

//>--
function hex_fromArrayOfBytes(arrayOfBytes) {
    const hexstr = arrayOfBytes.map(b => b.toString(16).padStart(2, '0')).join('');
    return(hexstr)
}
//--<

//>--
function hex_fromTypedArray(byteArray){
    let arrayOfBytes = Array.from(byteArray)
    return(hex_fromArrayOfBytes(arrayOfBytes))
}
//--<


//>--
function hex_fromByteArray(byteArray){
    return hex_fromTypedArray(ArrayOfBytes_toByteArray(byteArray))
}
//--<


//>--
function hex_toArrayOfBytes(hexString) {
    let result = [];
    for ( let i = 0; i < hexString.length; i += 2 ) {
      result.push(parseInt(hexString.substr(i, 2), 16));
    }
    return result;
}
//--<

//>--
function ArrayOfBytes_toByteArray(arrayOfBytes) {
    let byteArray = new Uint8Array(arrayOfBytes)
    return(byteArray)
}
//--<

//>--
function hex_toByteArray(hexstr) {
    let aob = hex_toArrayOfBytes(hexstr)
    return ArrayOfBytes_toByteArray(aob)
}
//--<

//>--
function bufferToArrayBufferCycle(buffer) {
  var ab = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
      view[i] = buffer[i];
  }
  return ab;
}
//--<

// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----

//>--
// export_wrapper_key
// --
async function export_wrapper_key(pub_key) {
    let exporter = await g_crypto.exportKey("jwk",pub_key)
    return exporter
}
//--<

//>--
// wv_unwrapped_key
// --
async function wv_unwrapped_key(wrapped_aes,unwrapper_key) {
    let unwrapped_aes = await g_crypto.unwrapKey(
        "jwk", // same as wrapped
        wrapped_aes, //the key you want to unwrap
        unwrapper_key, //the private key with "unwrapKey" usage flag
        {   //these are the wrapping key's algorithm options
            name: "RSA-OAEP"
        },
        {   //this what you want the wrapped key to become (same as when wrapping)
            name: "AES-CBC",
            length: 256
        },
        true, //whether the key is extractable (i.e. can be used in exportKey)
        ["encrypt", "decrypt"] //the usages you want the unwrapped key to have
    )
    //
    return unwrapped_aes
}
//--<

// wv_wrap_private_key
//
//  The the server public key and import it.
//  When the server sends the key, it will make a session that the client machine may use to associate a user with.
//
//  The endpoint will retunr in (server_pub_key), a pair { jwk, id }
//  The 'id' field will contain a unique identifier 
//

//>--
async function wv_wrap_private_key(key,nonce_buffer,email) {
    //
    let wrapper_key_pair = await wv_wrapper_keypair_promise()   // create key each time
    let PUB_wrapper_key = wrapper_key_pair.publicKey
    let PRIV_wrapper_key = wrapper_key_pair.privateKey
    //
    let PUB_wrapper_key_transport = await export_wrapper_key(PUB_wrapper_key)
    //
    let user_identification = {
        "user_key" : email,               // A unique name for this user
        "pub_wrapper_key" : PUB_wrapper_key_transport,        // send public wrapping key
        "device_id" : get_client_device_name()      // identify the devices as well as possible without plugins or compicated user interaction
    }
    // Ask for the server's public key
    let server_wrapped_key = await wv_postData(FETCH_SERVER_WRAPPER_KEY,user_identification)
    let wrapped_aes = server_wrapped_key.wrapped
    wrapped_aes = hex_toByteArray(wrapped_aes)
    let sess_id = server_wrapped_key.id
    let [hx_encrypted_key,hx_iv_str] = await wv_ecrypted_local_priv_key(key,wrapped_aes,PRIV_wrapper_key,nonce_buffer)
    //
    let serverReply = {     // for local use
        'encrypted_key' : hx_encrypted_key,
        'who' : sess_id,
        'iv' : hx_iv_str
    }
    //
    return(serverReply)
}
//--<


//>--
// wv_ecrypted_local_priv_key
// --
async function wv_ecrypted_local_priv_key(key,wrapped_aes,unwrapper_key,nonce_buffer) {
  //
  let unwrapped_aes = await wv_unwrapped_key(wrapped_aes,unwrapper_key)
  wv_active_key_to_worker(unwrapped_aes)
  //
  let key_bytes = await g_crypto.exportKey('jwk',key)
  let key_bytes_str = JSON.stringify(key_bytes)
  let enc = new TextEncoder()
  let encoded = enc.encode(key_bytes_str)
  crypto.getRandomValues(nonce_buffer)
  let encd_bytes = await g_crypto.encrypt({
                                              'name': "AES-CBC",
                                              'iv' : nonce_buffer
                                          },unwrapped_aes,encoded)
  let hx_encrypted_key = hex_fromByteArray(encd_bytes)
  let hx_iv = hex_fromTypedArray(nonce_buffer)
  return([hx_encrypted_key,hx_iv])
}
//--<

//>--
// wv_decrypted_local_priv_key
// --
async function wv_decrypted_local_priv_key(key_bytes,wrapped_aes,unwrapper_key,iv_buffer) {
  //
  let unwrapped_aes = await wv_unwrapped_key(wrapped_aes,unwrapper_key)
  wv_active_key_to_worker(unwrapped_aes)
  //
  let clear_key = await g_crypto.decrypt({
                                              name: "AES-CBC",
                                              iv : iv_buffer
                                          },unwrapped_aes,key_bytes)
  //
  let dec = new TextDecoder()
  let txt = dec.decode(clear_key)
  let clear_jwk = JSON.parse(txt)
  //
  let key = await g_crypto.importKey('jwk',clear_jwk,{
          'name': "ECDSA",
          'namedCurve': "P-384"
      },
      true,
      ["sign"]
  )
  return key
}
//--<


//>--
// fetch_restoration_key
// --
async function fetch_restoration_key(user_info) {
    // The server keeps a cipher key to be delivered over TLS... It is for this user. This device keeps an initialization vector
    // that the server does not have... (at this time, just relying on TLS to send the key unencrypted otherwise.)
    let wrapper_key_pair = await wv_wrapper_keypair_promise()   // create key each time
    let PUB_wrapper_key = wrapper_key_pair.publicKey
    let PRIV_wrapper_key = wrapper_key_pair.privateKey
    //
    let PUB_wrapper_key_transport = await export_wrapper_key(PUB_wrapper_key)

    let user_identification = {
        "user_key" : user_info.email,               // A unique name for this user
        "pub_wrapper_key" : PUB_wrapper_key_transport,        // send public wrapping key
        "sess_id" : user_info.server_id,
        "device_id" : get_client_device_name()      // identify the devices as well as possible without plugins or compicated user interaction
    }
    // Ask for the server's public key
    let server_wrapped_key = false
    try {
        server_wrapped_key = await wv_postData(FETCH_SERVER_WRAPPER_KEY_RESTORE,user_identification)
    } catch (e) {
        console.log(e)
    }
    if ( server_wrapped_key ) {
        let wrapped_aes = server_wrapped_key.wrapped
        if ( wrapped_aes !== undefined ) {
          wrapped_aes = hex_toByteArray(wrapped_aes)
          let iv_buffer = hex_toByteArray(user_info.iv)
          let enckey = hex_toByteArray(user_info.encrypted_key)
          let priv_key = await wv_decrypted_local_priv_key(enckey,wrapped_aes,PRIV_wrapper_key,iv_buffer)
          return(priv_key)
        } else if ( server_wrapped_key.no_key ) {
          alert('Please reenter user data: ' + server_wrapped_key.reason)
          throw new Error(server_wrapped_key)
        }
    }
    return false
}
//--<



// wv_reset_keys
// --
async function wv_reset_keys(user_info) {
  let pub_key = user_info.pub_key
  let priv_key = g_current_session_signing_key
  // ---- ---- ---- ----                                      // g_nonce_buffer - space to use
  let wrapped_key_info = await wv_wrap_private_key(priv_key,g_nonce_buffer,user_info.email)  // json object :: wrap private for local storage
  let exported = await g_crypto.exportKey("raw",pub_key);
  let exportedKeyBuffer = new Uint8Array(exported);
  let pub_key_str = hex_fromTypedArray(exportedKeyBuffer);

  user_info.encrypted_key = wrapped_key_info.encrypted_key
  user_info.iv = wrapped_key_info.iv
  //
  store_user_key(APP_USER_SINGLETON,user_info)
  //
  // ASK THE SERVER TO SAVE SOME INFORMATION ABOUT THIS FOR LATER RETRIEVAL
  let key_for_server = {      // don't send IV to the server
    'email' : user_info.email,
    'pub_key' : pub_key_str,  // store the public key
    'server_id' : user_info.key_session_id,
    'priv' : user_info.encrypted_key
  }
  post_user_key(key_for_server)       // possible to await

  return(key_info)
}




async function wv_restore_signing_key(user_info) {
  //
  let priv_key = await fetch_restoration_key(user_info) 
  // The user private key is stored locally, but encrypted
  // set global variables
  if ( priv_key ) {
    set_current_session_signing_key(priv_key)
    set_current_session_email(user_info.email)
    g_pub_verification_key = user_info.pub_key
  }
  return priv_key !== false
}


async function wv_setup_crypto() {
  if ( g_window_can_process && g_crypto && g_audio_db ) {
    //
    let user_info = null
    try {
      user_info = await wv_find_user(APP_USER_SINGLETON)
      let key_restored = await wv_restore_signing_key(user_info)
      if ( key_restored ) {
        if ( !(wv_user_info_to_worker(user_info)) ) {
          alert("Worker threads do not have user information - not initialized")
        }
      } else {
        alert("Could not restore signing key - remote server error.")
      }
    } catch (e) {                           // NO USER FOUND
      //  wv_ask_create_user  CREATE THE USER ENTRY   wv_ask_create_user
      wv_ask_create_user(APP_USER_SINGLETON)
    }
    //
  } else {
    alert("Crypotgraphy processing is not available within this browser at this time.")
  }
}

function stop_geo_update() {
  if ( g_geo_update ) clearInterval(g_geo_update)
}

function restart_geo_update() {
  if ( g_geo_update ) clearInterval(g_geo_update)
  //g_geo_update = setInterval(wv_getLocation,GEO_UPDATE_INTERVAL)
}

// ---- ---- ---- ---- ---- ----
async function initialize_db_and_crypto() {
  g_audio_db = await wv_init_database(gc_song_db_name)
  load_name_list()
  await wv_setup_crypto()
}

async function application_initialization() {
  wv_getLocation()
  init_user_dialog()
  wv_initialize_global_buttons()
  wv_init_recorder()
  //
  await initialize_db_and_crypto()
  //g_geo_update = setInterval(wv_getLocation,GEO_UPDATE_INTERVAL)  
}

// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----
if ( g_window_can_process ) {
  async function first_inializer() {
    await ensure_dialog_elements()
    application_initialization()
  }
  first_inializer()
}

if ( typeof g_current_pin !== "undefined" ) {
  g_current_pin.openAction = () => {
    let f = async () => { await initialize_db_and_crypto() }
    f()
  }
}

/*
*/
</script>
