<!DOCTYPE html>
<html>
<head>
    <title>Record and save audio</title>
    <style>
      audio {
        display: block;
        margin: 5px;
      }
      button {
        cursor: pointer;
        font-weight: 600;
        background-color: rgb(250, 244, 218);
        border-radius: 6px;
        border: 1px double #cccccc;
      }
      .like-button {
        font-weight: 600;
        font-size:68%;
        font-family: Arial, Helvetica, sans-serif;
        background-color: rgb(250, 244, 218);
        margin-right: 4px;
        margin-left: 2px;
      }
      #saved-audio-messages {
        max-height: 256px;
        overflow-y: scroll;
      }
      .component-container {
        border: rgb(126, 79, 9) solid 2px;
        padding: 4px;
      }
      .audio-checks {
       float: left
      }
      .audio-playback {
        display: inline;
      }
      .playback-div {
        width:100%;
        text-align:left;
        vertical-align:bottom;
        border-bottom: midnightblue solid 1px;
        padding: 2px;
      }
      .pop-name-list {
        visibility: hidden;
        display: none;
      }
      .pop-name-list-popped {
        visibility: visible;
        display: block;
      }

      .wave-graph-container {
        left: 10px;
        top: 10px;
        width: 80%;
        height: 40%;
        position:absolute;
        display: none;
        visibility: none;
        z-index: 100;
        border: 2px orangered solid;
        background-color: ivory;
      }
      .drag-bar-control {
        margin:0px;
        width: 100%;
        height: 20px;
        background-color: slateblue;
        color:goldenrod;
        cursor:move;
        text-align: right;
      }
      .wave-graph-canvas {
        width: 100%;
        height: 100%;
      }
      .wv-editor-close {
        font-size: 120%;
        height:10px;
        width:10px;
        text-align: center;
        vertical-align: middle;
        cursor: pointer;
      }
      .wave_edit_controls_container {
        display:inline-block;
        width: calc(100% - 20px);
        text-align: center;
        height: 100%;
      }

      dialog {
        padding: 0;
        border: 0;
        border-radius: 0.4rem;
        padding: 6px;
        box-shadow: 0 0 1em black;
        background-color: rgb(221, 214, 221);
      }

      dialog::backdrop {
        background: rgba(200, 200, 160, 0.25);
      }

      .wv-bq-dialog {
        max-width: 600px;
        border:rgb(250, 244, 218) solid 1px;
        background-color: rgba(255, 245, 238, 0.603);
        color:rgb(24, 57, 83);
        font-weight:400;
      }

    </style>
</head>
<body>
  <div class="component-container">
    <span style="font-weight: bolder;">Manage Recording Sessions</span>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
    <div class="like-button" style="display: inline;" >
      <label  for="wv-geo-location">Session Geolocation:</label>
      <span id="wv-geo-location">NaN,NaN</span>
    </div>
    
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
    <button onclick="ask_user_session()" >New Recording Session</button>
    <!--   -->
    <div class="like-button" style="display: inline;" >
    <label  for="sess-names">Edit Existing Session:</label>
    <select name="sess-names" id="sess-names" onchange="edit_user_session(event)">
      <option value="none">no selection</option>
    </select>
    </div>
    <!--   -->
    <button id="send-session" onclick="store_to_servers()" >Send Session to Servers</button>
    <button id="delete-session" onclick="delete_session()" >Delete Session from Device</button>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
    <!--   -->
    <span style="font-weight: bolder;">Record Audio</span>:&nbsp;&nbsp;&nbsp;&nbsp;
    <span id="show-session-name" style="font-weight: bolder;"></span>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
    <button id="record" disabled>Record</button>
    <button id="stop" disabled>Stop</button>
    <button id="play" disabled>Play</button>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>

    <span style="font-weight: bolder;">Save Audio</span>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
    <button id="save" disabled>Save</button>
    <button id="delete" disabled>Delete</button>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>

    <span style="font-weight: bolder;">Session Components</span>
    <div style="display: inline;padding:2px;background-color: oldlace">
      <button onclick="wv_edit_checked()" >edit checked</button>
      <button onclick="wv_delete_checked()" >delete checked</button>
    </div>
    <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;;margin-top: 2px;">&nbsp;</div>
    <div id="saved-audio-messages">
    </div>
  </div>
  <div id="wave-graph-tmplt" class='wave-graph-container'>
    <div class="drag-bar-control"
          onmousedown="wv_capture_cursor(event)"
          onmouseup="wv_release_captured_cursor(event,false)"
          onmouseout="wv_release_captured_cursor(event,true)"
          onmousemove="wv_track_cursor(event)"
        >
          <div class="wave_edit_controls_container"
            onmousedown="wv_capture_cursor(event,1)"
            onmouseup="wv_release_captured_cursor(event,false,1)"
            onmouseout="wv_release_captured_cursor(event,true,1)"
            onmousemove="wv_track_cursor(event,1)"
          >
            <button onclick="wv_zoom_in(event)">&downarrow;</button>
            <button onclick="wv_zoom_out(event)">&uparrow;</button>
            <button onclick="wv_scroll_left(event)">&leftarrow;</button>
            <button onclick="wv_scroll_right(event)">&rightarrow;</button>
            &nbsp;
            <button onclick="wv_cut_selection(event)">cut</button>
            <button onclick="wv_restore_selection(event)">undo</button>
          </div>
          <span class="wv-editor-close" onclick="wv_closer_editor(event)">x</span></div>
    <div style="width: 100%;height:calc(100% - 20px);">
      <canvas class="wave-graph-canvas"></canvas>
    </div>
  </div>
  <!-- wave template-->
  <dialog id="user-dialog">
    <h3 class="modal-header">Please enter your information.</h3>
    <div class="modal-body">
      <blockquote class="wv-bq-dialog">You are seeing this dialog box because this browser does not know of a user 
        to associate with new media being created here. This informationis being used to generate a secure key for signing
        the new media. A private key will be stored within your web browser on your device. A public key will be sent to our storage
        servers when you being to create media. At a later time you may elect to have your private key stored on our servers in
        an encrypted format for your later retrieval. <span style="color:slategrey">Providing your information here will not automatically sign you up to our
        site nor will it make you the target of advertising.
        </span></blockquote>
        <blockquote class="wv-bq-dialog">
          <form method="dialog">
            <label for="wv-id-email">Your identifying email:</label>
            <input type="text" id="wv-id-email" name="wv-id-email" />
          </form>
        </blockquote>
    </div>
    <footer class="modal-footer">
      <button id="wv-later" type="button">Later</button>
      <button id="wv-OK" type="button">This is my information</button>
    </footer>
  </dialog>
  <!-- end of dialog-->
</body>
</html>

<script>
  const AUDIO_SESSION_STORE = 'audio_sessions'
  const AUDIO_USERID_STORE = 'audio_users'
  const WV_CONST_MOUSE_DRAG_DIST_TOLERANCE = 82
  const WAVE_DISPLAY_MAX = 100
  const ZERO_AXIS_OFFSET = 10

  let recorder = false
  let audio = false
  let app_recoder = false
  let g_current_session_name = 'none'
  let g_session_name_list = []
  //

  let g_wave_open_editors = {}
  var g_wv_current_locaion = { 'latitude' : NaN,'longitude' : NaN}
  
  //
  const g_recordButton = document.getElementById('record');
  const g_stopButton = document.getElementById('stop');
  const g_playButton = document.getElementById('play');
  const g_saveButton = document.getElementById('save');
  const g_deleteButton = document.getElementById('delete');
  const g_send_session = document.getElementById('send-session')
  //
  const savedAudioMessagesContainer = document.querySelector('#saved-audio-messages');
  const g_user_modal = document.getElementById('user-dialog');

  var g_window_can_process = true
  // In the following line, you should include the prefixes of implementations you want to test.
  window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  // DON'T use "var indexedDB = ..." if you're not in a function.
  // Moreover, you may need references to some window.IDB* objects:
  window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
  window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
  // (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)

  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  //

  const g_audioContext = new AudioContext();

  var g_crypto = window.crypto ? window.crypto.subtle : null
  if ( g_crypto === null  ) {
    alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
  }

  if (!window.indexedDB) {
    g_window_can_process = false
    console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
  }

  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  let g_ownership_worker = new Worker('./hashers/ownership.js')


  g_ownership_worker.onmessage = (msg) => {
      //
    if ( msg.data.type === 'status' ) {
      worker_status_view(msg.data.message)
    }
    //
    if ( msg.data.type === 'op_complete' ) {
      worker_op_response(msg.data.message);
    }
  }

  var g_current_session_signing_key = null
  var g_current_session_email = ""
  function set_current_session_signing_key(key) {
    g_current_session_signing_key = key
  }

  function set_current_session_email(email) {
    g_current_session_email = email
  }

  //
  class AppAudioRecorder {
    //  //  //
    constructor(stream) {
      //
      this.audioChunks = [];
      let mediaRecorder = new MediaRecorder(stream);
      this.mediaRecorder = mediaRecorder
      this.audio_instance = null
      //
      mediaRecorder.addEventListener('dataavailable', event => {
        this.data_handler(event)
      });

      mediaRecorder.addEventListener('stop',  event => {
        this.stop_handler(event)
      });
    }
    //
    //
    data_handler(data) {
      let chunk = event.data
      this.audioChunks.push(chunk);
      this.relayAduioData(chunk)
    }
    //
    start() {
      this.audioChunks = []
      this.mediaRecorder.start();
    }
    //
    stop_handler(event) {
      this.audio_results()
    }

    stop() {
      this.mediaRecorder.stop();
    }

    //
    audio_results() {
      let audioBlob = new Blob(this.audioChunks);
      let audioUrl = URL.createObjectURL(audioBlob);
      this.audioBlob = audioBlob
      this.audio_instance = new Audio(audioUrl);
      wv_secure('end-recording',audioBlob)
    }

    delete_last_recorderd_audio() {
      this.audio_instance = null
      this.audioBlob = null
    }

    play() {
      if ( this.audio_instance ) {
        this.audio_instance.play()
      }
    }

    relayAduioData(chunk) {
      wv_prep_secure_relay(chunk)
    }

  }

  // DATABASE
  var g_audio_db = null
  const gc_song_db_name = "SongCatcher"
  async function wv_init_database(db_name) {
    // request an open of DB
    let request = window.indexedDB.open(db_name, 2);
    //
    request.onerror = (event) => {
      alert("This web app will not store recorded audio without the use of computer storage.")
    };
    request.onsuccess = (event) => {
      //
      let db = event.target.result;
      db.onerror = (event) => {
        console.log("Database error: " + event.target.error);
      };
      //
      g_audio_db = db;
      load_name_list()
      wv_setup_crypto()
      //
    };

    request.onupgradeneeded = (event) => {
        let db = event.target.result;

        let sessionObjectStore = db.createObjectStore(AUDIO_SESSION_STORE, { autoIncrement : true });
        sessionObjectStore.createIndex("name", "name", { unique: true });
        sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
        //
        db.createObjectStore(AUDIO_USERID_STORE, { autoIncrement : true });

        /*
        // Use transaction oncomplete to make sure the objectStore creation is 
        // finished before adding data into it.
        sessionObjectStore.transaction.oncomplete = function(event) {
          // Store values in the newly created objectStore.
          let customerObjectStore = db.transaction("customers", "readwrite").objectStore("customers");
          customerData.forEach(function(customer) {
            customerObjectStore.add(customer);
          });
        };
        */
      };

    //
  }



  function apply_find_audio_session(sess_name, store, success_callback, not_found_callback) {
    //
    var nameIndex = store.index('name');
    nameIndex.get(sess_name).onsuccess = (evt) => {
      var value = evt.target.result;
      if ( value ) {
        if ( success_callback ) success_callback(value,nameIndex);
      } else {
        if ( not_found_callback ) not_found_callback();
      }
    };
    //
  }

    ////////////////

  class WaveBlob {
    constructor() {
      this.recLength = 0
      this.recBuffer = []
      this.recordSampleRate = g_audioContext.sampleRate
    }

    clear() {
      this.recLength = 0;
      this.recBuffer = [];
    }

    record(inputBuffer) {
      this.recBuffer.push(inputBuffer);
      this.recLength += inputBuffer.length;
    }

    toBlob() {
      var mergedBuffers = this.interleaveLeftAndRight(this.recBuffer);
      var encodedWav = this.encodeWAV(mergedBuffers);
      var audioBlob = new Blob([encodedWav], {type: 'audio/wave'});
      return(audioBlob);
    }

    mergeBuffers(array_of_buffers, recLength) {
      let result = new Float32Array(recLength);
      let offset = 0;
      let n = array_of_buffers.length
      for ( let i = 0; i < n; i++ ) {
        result.set(array_of_buffers[i], offset);
        offset += array_of_buffers[i].length;
      }
      return result;
    }

    interleaveLeftAndRight(bufferList) {
      let left = bufferList[0]
      let right = bufferList[1]
      let totalLength = left.length + right.length;
      let data = new Float32Array(totalLength);
      let n = left.length
      for ( let i = 0; i < n; i++ ) {
        let k = i * 2;
        data[k] = left[i];
        data[k + 1] = right[i];
      }
      return(data)
    }


    // mutate output Int16
    floatTo16BitPCM(output, offset, input) {
      let n =  input.length
      for ( let i = 0; i < n; (i++, offset += 2) ) {
        let s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
    }

    writeString(view, offset, string) {
      for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    encodeWAV(samples) {
      const WAV_HEAD_SIZE = 44
      let channels = 2
      let dat_len = samples.length * 2
      let buffer = new ArrayBuffer((dat_len * 2) + WAV_HEAD_SIZE)

      let view = new DataView(buffer);

      let recordSampleRate = this.recordSampleRate
      // RIFF chunk descriptor/identifier
      this.writeString(view, 0, 'RIFF')
      // RIFF chunk length
      view.setUint32(4, WAV_HEAD_SIZE + (dat_len * 2), true)  // 32
      // RIFF type
      this.writeString(view, 8, 'WAVE');
      // format chunk identifier
      // FMT sub-chunk
      this.writeString(view, 12, 'fmt ');
      // format chunk length
      view.setUint32(16, 16, true);
      // sample format (raw)
      view.setUint16(20, 1, true);
       // stereo (2 channels)
      view.setUint16(22, channels, true);
      // sample rate
      view.setUint32(24, recordSampleRate, true);
      // byte rate (sample rate * block align)
      view.setUint32(28, recordSampleRate * 2, true);
      // block align (channel count * bytes per sample)
      view.setUint16(32, (channels * 2), true);
      // bits per sample
      view.setUint16(34, 16, true);
      // data sub-chunk
      // data chunk identifier
      this.writeString(view, 36, 'data');
      // data chunk length
      view.setUint32(40, samples.length * 2, true);
      this.floatTo16BitPCM(view, 44, samples);


      return view;
    }

  }




  function make_audio_blob(channel_data_list) {
    let d1 = channel_data_list[0]
    let d2 = channel_data_list[1]
    let wb = new WaveBlob()
    wb.record(d1)
    wb.record(d2)
    //
    let blob = wb.toBlob()
    //
    return(blob)
  }

  var wv_checkEmailField = () => {}
  var wv_fetchEndPoint = () => {}
  var wv_postData = () => {}

  if ( reEmail ===  undefined || typeof checkEmailField === 'undefined' ) {
    var reEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    function checkEmailField(efield) {
      let email = efield.value
      if ( !(reEmail.test(email)) ) {
        return(false)
      }
      return(true)
    }
    wv_checkEmailField = checkEmailField
  } else {
    wv_checkEmailField = checkEmailField
  }

  if ( fetchEndPoint === undefined ) {
    async function fetchEndPoint(endpoint,port) {
      port = !(port) ? '' : ( port.length ? `:${port}`   : '')
      let myRequest = new Request(`${location.protocol}//${g_siteURL}${port}/${endpoint}`);
      try {
        const body = await fetch(myRequest, {
                      method: 'GET', // *GET, POST, PUT, DELETE, etc.
                      mode: 'cors', // no-cors, *cors, same-origin
                      cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
                      credentials: 'omit', // include, *same-origin, omit
                      redirect: 'follow', // manual, *follow, error
                      referrerPolicy: 'no-referrer', // no-referrer, *client
                    });
        //
        let infoObj = await body.json();
        return(infoObj)
        //
      } catch (e) {
        console.log(e.message)
        return(false)
      }
    }
    wv_fetchEndPoint = fetchEndPoint
  } else {
    wv_fetchEndPoint = fetchEndPoint
  }


  if ( postData === undefined ) {
    async function postData(url = '', data = {}, creds = 'omit', do_stringify = true,ctype) {
      let content_type = 'application/json'
      if ( ctype !== undefined ) {
        content_type = ctype
      }
      let options = {
        method: 'POST', // *GET, POST, PUT, DELETE, etc.
        mode: 'cors', // no-cors, *cors, same-origin
        cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
        credentials: creds, // include, *same-origin, omit
        headers: {
          'Content-Type': content_type
        },
        redirect: 'follow', // manual, *follow, error
        referrerPolicy: 'no-referrer', // no-referrer, *client
        body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
      }

      if ( ctype === 'multipart/form-data') {
        delete options.headers['Content-Type']  // content type will be set automatically with a boundary
      }

      // Default options are marked with *
      const response = await fetch(url, options);
      if ( response.ok == false ) {
        console.log(response.status + ': ' + response.statusText)
        return {}
      } else {
        return await response.json(); // parses JSON response into native JavaScript objects
      }
    }
    wv_postData = postData
  } else {
    wv_postData = postData
  }

  function init_user_dialog() {
    const modal = g_user_modal
    //
    const do_this_later = document.getElementById('wv-later');
    const ready_to_go = document.getElementById('wv-OK');
    //
    //dialogPolyfill.registerDialog(modal);

    do_this_later.addEventListener('click', () => {
      modal.close('cancelled');
    });

    modal.addEventListener('cancel', () => {
      //modal.close('cancelled');
    });

    // close when clicking on backdrop
    modal.addEventListener('click', (event) => {
      if (event.target === modal) {
        modal.close('cancelled');
      }
    });

    // 
    ready_to_go.addEventListener('click', () => {
      if ( wv_checkEmailField(value_holder) ) {
        modal.close('ready');          
      } else {
        alert("Please enter a valid email address.")
      }
    });

   
  }


  async function wv_user_keys() {
      let keypair = await g_crypto.generateKey({
              'name': "ECDSA",
              'namedCurve': "P-384"
            },
            true,
            ["sign", "verify"]
          )

      let pub_key = keypair.publicKey
      let priv_key = keypair.privateKey
      let exported = await g_crypto.exportKey("raw",pub_key);
      let exportedKeyBuffer = new Uint8Array(exported);
      let pub_key_str = `${exportedKeyBuffer}`;
      let wrapped_key_info = await wv_wrap_private_key(priv_key)  // json object :: wrap private for local storage

      let key_info = {
        "pk_str" : pub_key_str,
        "priv_key" : priv_key, // access this for now for signing
        "wrapped_priv" : wrapped_key_info.wrapped_key,
        "key_session_id" : wrapped_key_info.who,
        "iv" : wrapped_key_info.iv
      }
      return(key_info)
  }

  function store_user_key(app_user_key,user_information) {
    let transaction = g_audio_db.transaction(AUDIO_USERID_STORE, "readwrite");
    let userStore = transaction.objectStore(AUDIO_USERID_STORE);
    user_information.app_key = app_user_key
    userStore.put(user_information)
  }

  async function post_user_key(key_for_server) {
    await wv_postData('transition/recording-key',key_for_server)
  }

  function wv_ask_create_user(app_user_key) {
    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: add_audio_data")
      return;
    }
    //
    const value_holder = document.getElementById('wv-id-email')
    g_user_modal.showModal();
    //
    const modal = g_user_modal
    modal.addEventListener('close', async () => {
      let modal_value = modal.returnValue
      if ( modal_value === 'ready' ) {
        //
        let user_email = value_holder.value
        let key_info = await wv_user_keys()
        //
        set_current_session_signing_key(key_info.priv_key)    // use it now for signing
        set_current_session_email(user_email)
        //
        let user_information = {
          'email' : user_email,
          'wrapped_priv' : key_info.wrapped_priv,  // store the private key
          'iv' : key_info.iv,
          'server_id' : key_info.key_session_id
        }
        store_user_key(app_user_key,user_information)
        let key_for_server = {
          'email' : user_email,
          'pub_key' : key_info.pk_str,  // store the private key
          'iv' : key_info.iv,
          'server_id' : key_info.key_session_id,
          'priv' : key_info.priv_key
        }
        post_user_key(key_for_server)
        wv_user_info_to_worker(user_information)
        //
      } else {
      }
    });

  }

  function wv_find_user(app_user_key) {
    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: add_audio_data")
      return;
    }
    //
    let transaction = g_audio_db.transaction(AUDIO_USERID_STORE, "readwrite");
    let userStore = transaction.objectStore(AUDIO_USERID_STORE);
    //
    let found_user = null
    let request = userStore.openCursor();
    let resolver, rejector
    let p = new Promise( (resolve,reject) => {
      request.onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          let test_user = cursor.value
          let test = test_user.id = app_user_key
          if ( resolver && test ) {
            found_user = test_user
            resolve(found_user)
          } else cursor.continue();
        } else {
          reject(found_user)
        }
      };
    })
    
    return p
  }


  function update_audio_data(map_id,data_list) {
    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: add_audio_data")
      return;
    }
    //
    let audioBlob = make_audio_blob(data_list)
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

    let update_list_elem_callback = (value,dbIndex) => {
      let keyRangeValue = IDBKeyRange.only(value.name);
      dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          let sessionObj = cursor.value
          if ( sessionObj.data[map_id] != null ) {
            let blob_url = URL.createObjectURL(audioBlob);
            sessionObj.data[map_id] = audioBlob
            wv_secure('edit-update',audioBlob,map_id)
            //
            const request = cursor.update(sessionObj);
            request.onsuccess = () => {
              update_audio_element(blob_url,map_id,audioBlob)  // visual rep
            };
          }
          //
        }
      }
    }

    let not_found_callback = () => {
      warn(`The session ${sess_name} is not in the database`)
    }

    apply_find_audio_session(g_current_session_name, audioStore, update_list_elem_callback, not_found_callback)
  }

  function add_audio_data(audioBlob) {

    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: add_audio_data")
      return;
    }
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

    let update_list_callback = (value,dbIndex) => {
      let keyRangeValue = IDBKeyRange.only(value.name);
      dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          let sessionObj = cursor.value
          let blob_url = URL.createObjectURL(audioBlob);
          let map_id = uuidv4()
          sessionObj.data[map_id] = audioBlob
          let geo_update = JSON.stringify(g_wv_current_locaion)
          if ( sessionObj.locations.indexOf(geo_update) < 0 ) {
            sessionObj.locations.push(geo_update)
          }
          //
          const request = cursor.update(sessionObj);
          request.onsuccess = () => {
            add_audio_element(blob_url,map_id,audioBlob)  // visual rep
          };
          //
        }
      }
    }

    let add_new_callback = () => {
      let blob_url = URL.createObjectURL(audioBlob);
      let sessionObj = {
        'name' : g_current_session_name,
        'sess_date_time' : '' + Date.now(),
        'sess_geo_location' : JSON.stringify(g_wv_current_locaion),
        'data' : { },
        'hashes' : { },
        'locations' : [JSON.stringify(g_wv_current_locaion)]
      }
      //
      let map_id = uuidv4()
      sessionObj.data[map_id] = audioBlob   // JSON.stringify(audioBlob)
      //
      let request = audioStore.add(sessionObj);
      request.onsuccess = function(event) {
        add_audio_element(blob_url,map_id,audioBlob)  // visual rep
      };
    }

    apply_find_audio_session(g_current_session_name, audioStore, update_list_callback, add_new_callback)
    //
  }


  function remove_audio_data(audio_key) {
    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: remove_audio_data")
      return;
    }
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

    let remove_from_list_callback = (value,dbIndex) => {
      let keyRangeValue = IDBKeyRange.only(value.name);
      dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
        var cursor = event.target.result;
        if ( cursor ) {
          let sessionObj = cursor.value
          delete sessionObj.data[audio_key]
          //
          const request = cursor.update(sessionObj);
          request.onsuccess = () => {
            //  item has been removed
            console.log(`deleted ${audio_key}`)
          };
          //
        }
      }
    }

    let not_found_callback = () => {
      warn(`The session ${sess_name} is not in the database`)
    }

    apply_find_audio_session(g_current_session_name, audioStore, remove_from_list_callback, not_found_callback)

  }

  function is_new_name(name) {
    if ( g_session_name_list.indexOf(name) >= 0 ) return(false)
    return(true)
  }

  function load_name_list() {
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readonly");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);
    //
    g_session_name_list = []
    var myIndex = audioStore.index('name');
    myIndex.openCursor().onsuccess = (event) => {
      var cursor = event.target.result;
      if(cursor) {
        g_session_name_list.push(cursor.value.name)
        cursor.continue();
      } else {
        update_session_name_selections(g_current_session_name,g_session_name_list)
      }
    };
    //
  }

  function update_session_name_selections(sess_name,name_list) {
    let session_options = name_list.map(name => {
      let el_html = `<option value='${name}'>${name}</option>`
      return(el_html)
    })

    let no_option = `<option value="none">no selection</option>`
    session_options.unshift(no_option)
    let options = session_options.join('\n')
    let sessNameSel = document.getElementById('sess-names')
    if ( sessNameSel ) {
      sessNameSel.innerHTML = options
      sessNameSel.value = sess_name
    }
    let sess_name_el = document.getElementById('show-session-name')
    if ( sess_name_el ) sess_name_el.innerHTML = (sess_name === 'none') ? '<span style="color:orange">select or create a session</span>' : sess_name
  }

  function warn(str) {
    //
  }

  function ask_user_session() {
    let proceed = confirm("Start a new session?")
    if ( proceed ) {
      let name = prompt("Name this session:", "new session");
      let new_name = is_new_name(name)
      if ( new_name ) {
        let sess_name_el = document.getElementById('show-session-name')
        if ( sess_name_el ) {
          g_current_session_name = name
          g_session_name_list.push(name)
          sess_name_el.innerHTML = name
          g_recordButton.removeAttribute('disabled');
          //
          clear_play_list()
          update_session_name_selections(g_current_session_name,g_session_name_list)
        }
      } else {
        warn("Session already exists. Do you want to edit it?")
      }
    }
  }


  async function choose_edit_user_session(name) {
    //
    if ( g_current_session_name !== 'none' ) {
      await wv_secure_total_session(g_current_session_name)
    }
    //
    if ( name === 'none' ) {
      let sess_name_el = document.getElementById('show-session-name')
      if ( sess_name_el ) {
        g_current_session_name = 'none'
        sess_name_el.innerHTML = '<span style="color:orange">select or create a session</span>'

        g_recordButton.setAttribute('disabled', true);
        g_stopButton.setAttribute('disabled', true);
        g_playButton.setAttribute('disabled', true);
        g_saveButton.setAttribute('disabled', true);
        g_deleteButton.setAttribute('disabled', true);
        clear_play_list()
        let sess_op_el = null
        sess_op_el = document.getElementById('send-session')
        if ( sess_op_el ) {
          sess_op_el.style.visibility = "hidden"
        }
        sess_op_el = document.getElementById('delete-session')
        if ( sess_op_el ) {
          sess_op_el.style.visibility = "hidden"
        }
      }
    } else {
      let sess_name_el = document.getElementById('show-session-name')
      if ( sess_name_el ) {
        g_current_session_name = name
        sess_name_el.innerHTML = name
        g_recordButton.removeAttribute('disabled');
        g_stopButton.setAttribute('disabled', true);
        g_playButton.setAttribute('disabled', true);
        g_saveButton.setAttribute('disabled', true);
        g_deleteButton.setAttribute('disabled', true);
        //
        clear_play_list()
        let sess_op_el = null
        sess_op_el = document.getElementById('send-session')
        if ( sess_op_el ) {
          sess_op_el.style.visibility = "visible"
        }
        sess_op_el = document.getElementById('delete-session')
        if ( sess_op_el ) {
          sess_op_el.style.visibility = "visible"
        }
        populate_play_list(g_current_session_name)
      }
    }
    wv_change_session_name()
  }

  function edit_user_session(event) {
    let sessNameSel = document.getElementById('sess-names')
    choose_edit_user_session(sessNameSel.value)
  }


  function delete_session() {
    if ( g_current_session_name !== 'none ') {
      let sess_name = g_current_session_name
      if ( g_audio_db === null ) {
        console.log("db not initialized :: add_audio_data")
        return;
      }
      //
      let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readwrite");
      let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

      let delete_from_list_callback = (value,dbIndex) => {
        let sessionObj = value
        let keyRangeValue = IDBKeyRange.only(value.name);
        dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
          var cursor = event.target.result;
          if ( cursor ) {
            var request = cursor.delete();
            request.onsuccess = function() {
              g_current_session_name = 'none'
              load_name_list()
            };
          }
        }
      }

      let not_found_callback = () => {
        warn(`The session ${sess_name} is not in the database`)
      }

      apply_find_audio_session(sess_name, audioStore, delete_from_list_callback, not_found_callback)    
    }
  }
  function store_to_servers() {
    if ( g_current_session_name !== 'none ') {
      
    }
  }

  
  // RECORDER
  async function wv_init_recorder() {
    const stream = await navigator.mediaDevices.getUserMedia({ 'audio': true });
    app_recoder = new AppAudioRecorder(stream)
  }

  //
  const sleep = time => new Promise(resolve => setTimeout(resolve, time));

  function wv_initialize_global_buttons() {
    //
    g_recordButton.setAttribute('disabled', true);
    g_stopButton.setAttribute('disabled', true);
    g_playButton.setAttribute('disabled', true);
    g_saveButton.setAttribute('disabled', true);
    g_deleteButton.setAttribute('disabled', true);
    let sess_op_el = null
    sess_op_el = document.getElementById('send-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "hidden"
    }
    sess_op_el = document.getElementById('delete-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "hidden"
    }

    // RECORD
    g_recordButton.addEventListener('click', async () => {
      g_recordButton.setAttribute('disabled', true);
      g_stopButton.removeAttribute('disabled');
      g_playButton.setAttribute('disabled', true);
      g_saveButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      app_recoder.start();
    });

    // STOP RECORD
    g_stopButton.addEventListener('click', async () => {
      g_recordButton.removeAttribute('disabled');
      g_stopButton.setAttribute('disabled', true);
      g_playButton.removeAttribute('disabled');
      g_saveButton.removeAttribute('disabled');
      g_deleteButton.removeAttribute('disabled');
      app_recoder.stop();
    });

    // PLAY
    g_playButton.addEventListener('click', () => {
      app_recoder.play();
    });

    // DELETE
    g_deleteButton.addEventListener('click', async () => {
      g_saveButton.setAttribute('disabled', true);
      g_playButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      app_recoder.delete_last_recorderd_audio()
    })

    // SAVE
    g_saveButton.addEventListener('click', () => {
      if ( app_recoder.audioBlob ) {
        add_audio_data(app_recoder.audioBlob)
      }
    });

  }


  function update_audio_element(audio_el_url,index,audioBlob) {
    if ( index === undefined ) return
    else {
      let audioElement = document.getElementById(`audio-player-${index}`)
      if ( audioElement ) {
        audioElement.src = audio_el_url;
        audioElement.setAttribute('data-audio-filename', audio_el_url);
        audioElement.pause()
        audioElement.load()
        let divEl = document.getElementById(`audio-div-${index}`)
        if ( divEl ) {
          divEl._ref_audio_data = audioBlob
        }
      }
    }
  }


  function add_audio_element(audio_el_url,index,audioBlob) {
    if ( index === undefined ) index = uuidv4()
    let audioElement = document.createElement('audio');
    audioElement.src = audio_el_url;
    audioElement.setAttribute('data-audio-filename', audio_el_url);
    audioElement.setAttribute('controls', true);
    audioElement.className = "audio-playback"
    audioElement.id = `audio-player-${index}`
    // ontimeupdate
    // add a playback track
    let divEl = document.createElement('div')
    divEl.id = `audio-div-${index}`
    divEl._ref_audio_data = audioBlob
    divEl.className = "playback-div"
    let checkEl = document.createElement('input')
    checkEl.type = "checkbox";
    checkEl.name = `audioSections`;
    checkEl.className = "checkEl"
    checkEl.value = "";
    checkEl.id = `audio-cbox-${index}`;
    divEl.appendChild(checkEl)
    divEl.appendChild(audioElement)
    // add the element
    savedAudioMessagesContainer.appendChild(divEl);
  }


  function clear_play_list() {
    if ( savedAudioMessagesContainer ) {
      let wave_keys = Object.keys(g_wave_open_editors)
      wave_keys.forEach( wave_name => { remove_wave_editor(wave_name) } )
      savedAudioMessagesContainer.innerHTML = ""
    }
  }


  function populate_play_list(sess_name) {
    //
    if ( g_audio_db === null ) {
      console.log("db not initialized :: add_audio_data")
      return;
    }
    //
    let transaction = g_audio_db.transaction(AUDIO_SESSION_STORE, "readonly");
    let audioStore = transaction.objectStore(AUDIO_SESSION_STORE);

    let update_list_callback = (value) => {
      let sessionObj = value
      let blob_map = sessionObj.data
      for ( let blob_id in blob_map ) {
        let audioBlob = blob_map[blob_id]
        let blob_url = URL.createObjectURL(audioBlob)
        add_audio_element(blob_url,blob_id,audioBlob)
      }
    }

    let not_found_callback = () => {
      warn(`The session ${sess_name} is not in the database`)
    }

    apply_find_audio_session(sess_name, audioStore, update_list_callback, not_found_callback)

  };

  // WAVE EDITOR FUNCIONALITY


  function draw_h_line(ctx, x, y, width, thick, color) {
    ctx.lineWidth = thick; // how thick the line is
    ctx.strokeStyle = color; // what color our line is
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo((x + width), y);
    ctx.stroke();
  }

  function draw_v_line(ctx, x, y, height, thick, color) {
    ctx.lineWidth = thick; // how thick the line is
    ctx.strokeStyle = color; // what color our line is
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, (y + height));
    ctx.stroke();
  }


  function draw_short_line(ctx, x0, y0, x1, y1, thick, color) {
    ctx.lineWidth = thick; // how thick the line is
    ctx.strokeStyle = color; // what color our line is
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  function draw_line_chart(ctx,x0,y0,data,offset,n,thick, color) {
    ctx.lineWidth = thick; // how thick the line is
    ctx.strokeStyle = color; // what color our line is
    ctx.beginPath();
    ctx.closePath();
    //
    let x = x0
    ctx.moveTo(x,y0);
    for ( let i = 0; i < n; (i++,x++) ) {
      ctx.lineTo(x, -data[i+offset]);    // canvas is upside down
    }
    ctx.stroke();
  }


  function wv_clear_selection(player_info) {
    if ( player_info.save_selection.startX !== undefined ) {
      let ctx = player_info.graph
      let saved_comp = ctx.globalCompositeOperation 
      let rect = player_info.save_selection
      ctx.globalCompositeOperation = 'xor'
      ctx.fillStyle = "#000000";
      ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      ctx.globalCompositeOperation = saved_comp
      player_info.save_selection = {}
    }
  }

  const randomArray = (length, max) => [...new Array(length)]
      .map(() => Math.round(Math.random() * max  - max/2));

  async function get_wave_data(wave_name,channels) {  // sample_ratio up or down sample
    let player_div = document.getElementById(`audio-div-${wave_name}`)
    let audio_blob = player_div._ref_audio_data
    const audioContext = new AudioContext();
    // audio blob contains blob data
    let arrayBuffer = await audio_blob.arrayBuffer();
    let audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
    if ( (channels === undefined) || (channels === 1) ) {
      let rawData = audioBuffer.getChannelData(0);
      return rawData      
    } else {
      let rawData = []
      let nchan = Math.min(audioBuffer.numberOfChannels,channels)
      for ( let i = 0; i < nchan; i++ ) {
        rawData.push(audioBuffer.getChannelData(i))
      }
      return(rawData)
    }
  }

  //
  // spp -- samples per pixel
  function reduceAudioPeak(data, spp, scroll, width) {
    if ( spp <= 1 ) return(data)
    //
    let drawData = new Array(width);
    let startSample = scroll * spp; 
    // For each pixel in draw area
    for ( let i = 0; i < width; i++ ) {
        let min = 0; // minimum value in sample range
        let max = 0; // maximum value in sample range
        let k = startSample + (i * spp);

        // Iterate over the sample range for this pixel (spp) 
        // and find the min and max values. 
        let avg = 0.0
        for ( let j = 0; j < spp; (j++,k++) ) {
           if ( k < data.length ) {
               let val = data[k];
               avg += val
           }
        }
        avg = avg/spp

        drawData[i] = avg;
    }
    return drawData;
}




function draw_wave(data,ctx,W,h) {
    // Set up the canvas
    ctx.clearRect(0,-h,W,(2*h))
    draw_h_line(ctx, 0, 0, W, 2, '#009')
    let offset = ZERO_AXIS_OFFSET
    draw_v_line(ctx, offset, -h, (2*h), 2, '#9999A9')
    //
    // size data to visible
    let n_pixels = (W - offset)
    let samples_per_pixel = Math.ceil(data.length/n_pixels)
    let dmax = Math.max(...data)
    let section_start = 0 //data.indexOf(dmax) - 200
    let dmin = Math.abs(Math.min(...data))
    dmax = Math.max(dmin,dmax)
    let factor = WAVE_DISPLAY_MAX/dmin
    data = data.map(datum => datum*factor)
    let draw_data = reduceAudioPeak(data, samples_per_pixel, 0, n_pixels)
    //
    draw_line_chart(ctx, 10, 0, draw_data, section_start, n_pixels, 1, '#000')
  }

  function update_play_marker(ctx,play_info,percent) {
    let last_tick = play_info.where_ticker
    let offset = ZERO_AXIS_OFFSET
    let width = play_info.width - offset
    let where_now = Math.round(width*percent) + offset
    play_info.where_ticker = where_now
    //
    let saved_comp = ctx.globalCompositeOperation
    ctx.globalCompositeOperation = 'xor'
    ctx.fillStyle = "#000000";
    ctx.fillRect(last_tick,-play_info.height,2,(2*play_info.height));
    ctx.fillRect(where_now,-play_info.height,2,(2*play_info.height));
    ctx.globalCompositeOperation = saved_comp
  }


  async function open_wave_editor(wave_name) {
    let div = document.getElementById('wave-graph-tmplt')
    let clone = div.cloneNode(true); // true means clone all childNodes and all event handlers
    clone.id = wave_name;
    document.body.appendChild(clone);
    clone.style.display = 'block'
    clone.style.display = 'visible'
    clone._app_dragging = false
    //
    let canvas = clone.getElementsByTagName('canvas')[0];
    //
    const dpr = window.devicePixelRatio || 1;
    const padding = 20;
    canvas.width = canvas.offsetWidth * dpr;
    canvas.height = (canvas.offsetHeight + padding * 2) * dpr;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);
    ctx.translate(0, canvas.offsetHeight / 2 + padding); // Set Y = 0 to be in the middle of the canvas
    //
    let audio_el = document.getElementById(`audio-player-${wave_name}`)
    if ( audio_el ) {
      audio_el.ontimeupdate = (event) => {
        let aud_el = event.target
        if ( aud_el ) {
          let play_time = aud_el.currentTime
          let duration = aud_el.duration
          let percent = play_time/duration
          let play_info = g_wave_open_editors[wave_name]
          let ctx = play_info.graph
          let prev_offset = play_info.where_ticker
          update_play_marker(ctx,play_info,percent)
        }
      }
    }
    //
    g_wave_open_editors[wave_name] = { 
      'display' : clone, 
      'canvas' : canvas, 
      'graph' : ctx, 
      'player' : audio_el, 
      'where_ticker' : 0, 
      'width' : canvas.offsetWidth,
      'height' : canvas.height,
      'selection_rect' : {},
      'save_selection' : {},
      'ops_undo_stack' : [],
      'dragging' : false
    }
    //
    let data = await get_wave_data(wave_name)
    let W = canvas.offsetWidth
    let h = canvas.height
    //
    draw_wave(data,ctx,W,h) 
    //
    // Editor Drawing Events
    let player_info = g_wave_open_editors[wave_name]
    let wv_edit_mouseDown = (e) => {
      //
      wv_clear_selection(player_info)
      //
      player_info.selection_rect = {}
      let container = player_info.display
      player_info.selection_rect.startX = e.pageX - container.offsetLeft;
      player_info.selection_rect.startY = -player_info.height //e.pageY - canvas.offsetTop;
      player_info.selection_rect.h = (2*player_info.height)
      player_info.selection_rect.w = 0
      player_info.dragging = true;
    }
    let wv_edit_mouseUp = (e) => { player_info.dragging = false }
    let wv_edit_mouseMove = (e) => {
      if ( player_info.dragging ) {
        let canvas = player_info.canvas
        let saved_comp = ctx.globalCompositeOperation
        let rect = player_info.selection_rect
        ctx.globalCompositeOperation = 'xor'
        ctx.fillStyle = "#000000";
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
        let container = player_info.display
        rect.w = (e.pageX - container.offsetLeft) - rect.startX;
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
        ctx.globalCompositeOperation = saved_comp
        player_info.save_selection.startX = rect.startX
        player_info.save_selection.startY = rect.startY
        player_info.save_selection.w = rect.w
        player_info.save_selection.h = rect.h
      }
    }
    canvas.addEventListener('mousedown', wv_edit_mouseDown, false);
    canvas.addEventListener('mouseup', wv_edit_mouseUp, false);
    canvas.addEventListener('mousemove', wv_edit_mouseMove, false);
  }

    //g_wave_open_editors[wave_name] = { 'display' : clone, 'graph' : ctx }
  //
  var g_wave_current_container = null
  //
  function remove_wave_editor(wave_name) {
    let editor_data = g_wave_open_editors[wave_name]
    if ( editor_data ) {
      let container = editor_data.display
      if ( container ) container.remove()
      delete  g_wave_open_editors[wave_name]
    }
  }
  //
  function wv_closer_editor(e) {
    e = e || window.event;
    e.preventDefault();

    let t = e.target
    if ( t ) {
      try {
        g_wave_current_container = null
        let container = t.parentNode.parentNode
        let wave_name = container.id
        remove_wave_editor(wave_name)
      } catch(e) {
      }
    }
  }

  // //
  // //
  function wv_zoom_in(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode
    if ( container ) {

    }
  }
  
  function wv_zoom_in(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode
    if ( container ) {

    }
  }

  function wv_scroll_left(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode
    if ( container ) {

    }
  }

  function wv_scroll_right(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode
    if ( container ) {
      
    }
  }

//update_audio_data(map_id,audioBlob)
  function wv_cut_data(data,selection_rect,samples_per_pixel) {
    let start = (selection_rect.startX)*samples_per_pixel
    let end = (selection_rect.w)*samples_per_pixel + start
    let tail_data = data.subarray(end)
    data.set(tail_data,start)
    let display_data = data.slice(0,(start + tail_data.length))
    return(display_data)
  }

  async function wv_cut_selection(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode.parentNode
    if ( container ) {
      let wave_name = container.id
      let player_info = g_wave_open_editors[wave_name]
      //
      let canvas = player_info.canvas
      if ( canvas && (player_info.save_selection.startX !== undefined) ) {
        if ( player_info.save_selection.w <= 0 ) {
          if ( player_info.save_selection.w === 0 ) return
          else {
            let w = player_info.save_selection.w
            let sx = player_info.save_selection.startX + w
            player_info.save_selection.w = -w
            player_info.save_selection.startX = sx
          }
        }
        //
        let data_list = await get_wave_data(wave_name,2)
        player_info.ops_undo_stack.push({ 'op' : 'cut',
                                                'data' : new Float32Array(data_list[0]), 
                                                'data2' : new Float32Array(data_list[1]) })
        let W = canvas.offsetWidth
        let h = canvas.height
        let n_pixels = (W - ZERO_AXIS_OFFSET)
        let samples_per_pixel = Math.ceil(data_list[0].length/n_pixels)
        let display_data = wv_cut_data(data_list[0],player_info.save_selection,samples_per_pixel)
        let c2_data = null
        if ( data_list.length > 1 ) {
          c2_data = wv_cut_data(data_list[1],player_info.save_selection,samples_per_pixel)
        } else {
          c2_data = new Float32Array(display_data)
        }
        
        //
        wv_clear_selection(player_info)
        let ctx = player_info.graph
        draw_wave(display_data,ctx,W,h)
        //
        data_list = [display_data,c2_data]
        update_audio_data(wave_name,data_list)
      }
    }
  }
/*
  function wv_save_current_buffer(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode
    if ( container ) {
      
    }
  }
*/
  function wv_restore_selection(ev) {
    ev = ev || window.event;
    ev.preventDefault();
    let the_button = ev.target
    let container = the_button.parentNode.parentNode.parentNode
    if ( container ) {
      let wave_name = container.id
      let player_info = g_wave_open_editors[wave_name]
      //
      if (  player_info.ops_undo_stack.length ) {
        let undo_op = player_info.ops_undo_stack.pop()
        let data = null
        if ( undo_op.op === 'cut' ) {
          let canvas = player_info.canvas
          if ( canvas ) {
            data = undo_op.data
            //
            let W = canvas.offsetWidth
            let h = canvas.height
            let ctx = player_info.graph
            draw_wave(data,ctx,W,h)
            //
            let data2 = undo_op.data2
            let data_list = [data,data2]
            update_audio_data(wave_name,data_list)
          }
        }
      }
    }
  }
  // // //

  //
  function wv_capture_cursor(ev,el_depth)  {
    ev = ev || window.event;
    ev.preventDefault();

    let controlBar = ev.target
    if ( controlBar ) {
      let container = controlBar.parentNode
      if ( el_depth ) container = container.parentNode
      if ( container ) {
        let x = ev.clientX;
        let y = ev.clientY; 
        container._app_mouse_x = x
        container._app_mouse_y = y
        container._app_dragging = true
        g_wave_current_container = container
        document.addEventListener('mouseup',(ev) => {
          if ( g_wave_current_container != null ) {
            g_wave_current_container._app_dragging = false
          }
        })
      }
    }
  }
  //
  function wv_release_captured_cursor(ev,check_limits,el_depth) {
    ev = ev || window.event;
    if ( !check_limits ) ev.preventDefault();
    //
    let controlBar = ev.target
    if ( controlBar ) {
      let container = controlBar.parentNode
      if ( el_depth ) container = container.parentNode
      if ( container ) {
        if ( check_limits ) {
          let check_y = Math.abs(container.offsetTop - ev.clientY)
          let check_x = Math.abs(container._app_mouse_x - ev.clientX)
          let dist = Math.sqrt((0.25)*check_y*check_y + check_x*check_x)
          if ( dist < WV_CONST_MOUSE_DRAG_DIST_TOLERANCE ) return
        }
        container._app_dragging = false
      }
    }
  }
  //
  function wv_track_cursor(ev,el_depth) {
    ev = ev || window.event;
    ev.preventDefault();
    //
    let controlBar = ev.target
    if ( controlBar ) {
      let container = controlBar.parentNode
      if ( el_depth ) container = container.parentNode
      if ( container && container._app_dragging ) {
        // calculate the new cursor position:
        let prev_x = container._app_mouse_x - ev.clientX;
        let prev_y = container._app_mouse_y - ev.clientY;
        container._app_mouse_x = ev.clientX;
        container._app_mouse_y = ev.clientY;
        // set the element's new position:
        let new_y = (container.offsetTop - prev_y)
        let new_x = (container.offsetLeft - prev_x)
        if ( new_y > 8 ) container.style.top = new_y + "px";
        if ( new_x > 8 ) container.style.left = new_x + "px";
      }
    }
  }
  //
  function wv_edit_checked() {
    var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
    checkedBoxes.forEach(cbox => {
      let wave_name = cbox.id.replace('audio-cbox-','')
      open_wave_editor(wave_name)
    })
  }
  // 
  function wv_delete_checked() {
    var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
    checkedBoxes.forEach(cbox => {
      let cbox_id = cbox.id
      let container_id = cbox_id.replace('cbox','div')
      let container = document.getElementById(container_id)
      if ( container ) {
        let parent = savedAudioMessagesContainer //container.parentNode()
        parent.removeChild(container)
        remove_audio_data(cbox_id.replace('audio-cbox-',''))
      }
    })
  }

  // ---- ---- ---- ---- ---- ----
  // ---- ---- ---- ---- ---- ----
  function wv_prep_secure_relay(data_chunk) {
    // relay to worker
    let message = {
      'type' : 'chunk',
      'chunk' : data_chunk,
      'sess_name' : g_current_session_name
    }
    g_ownership_worker.postMessage(message)
  }


  function wv_user_info_to_worker(user_info) {
    let message = {
      'type' : 'init',
      'user' : user_info
    }
    g_ownership_worker.postMessage(message)
  }

  function wv_secure(op,audioBlob,id_param) {  // edit-update, end-recording
    // relay to worker
    let message = {
      'type' : 'benchmark',
      'blob' : audioBlob,
      'op' : op,
      'blob_id' : (id_param ? id_param : ('ER-' + uuidv4()))
    }
    g_ownership_worker.postMessage(message)
  }

  function wv_secure_total_session(sess_name) {
    // save the entire session make a version of it for downloadings
    let message = {
      'type' : 'storage',
      'sess_id' : g_current_session_name
    }
    g_ownership_worker.postMessage(message)
  }

  function wv_change_session_name() {
    let message = {
      'type' : 'session',
      'db_id' : g_current_session_name
    }
    g_ownership_worker.postMessage(message)
  }

  function worker_status_view(status) {
    //
  }

  function worker_op_response(data) {
    //
  }
  // ---- ---- ---- ---- ---- ----
  // ---- ---- ---- ---- ---- ----

  function wv_getLocation() {
    if (navigator.geolocation) {
      var x = document.getElementById("wv-geo-location");
      navigator.geolocation.getCurrentPosition((position) => {
        x.innerHTML = `${position.coords.latitude},${position.coords.longitude}`
        g_wv_current_locaion = JSON.parse(JSON.stringify(position.coords))
      });
    } else { 
      alert("Geolocation is not supported by this browser.");
    }
  }

// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey
  /*
  Convert  an ArrayBuffer into a string
  from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
  */
  function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
  }


  // ---- ---- ---- ---- ---- ----
  // ---- ---- ---- ---- ---- ----

  //
  async function wv_wrap_private_key(key) {
    //
    let server_pub_key = await wv_fetchEndPoint('static/key_wrapper_pub_key')

    // get AES key from the server to wrap my public key and an identifier for recovering the AES key
    let pub_key = await g_crypto.importKey("jwk",server_pub_key.jwk,"AES-CBC", true, ["wrapKey"])
    let key_session_id = server_pub_key.id
    //
    let iv = window.crypto.getRandomValues(new Uint8Array(12));
    let wrapped_key = await g_crypto.wrapKey("jwk",key,pub_key,{
      'name' : "AES-CBC",
      'iv' : iv
    })
    //
    let iv_str = ab2str(iv)
    let serverReply = {
      'wrapped_key' : wrapped_key,
      'who' : key_session_id,
      'iv' : iv_str
    }
    //
    return(serverReply)
  }

  async function wv_restore_signing_key(user_info) {
    //
    let server_pub_key = await wv_fetchEndPoint(`static/restore_wrapper_key/${user_info.server_id}`)
    let wrapper_key = await g_crypto.importKey("jwk",server_pub_key.jwk,"AES-CBC", true, ["unwrapKey"])
    let iv = window.atob(user_info.iv) 
    let priv_key = await g_crypto.unwrapKey("jwk",user_info.wrapped_priv,wrapper_key,
                                                    {
                                                      'name' : "AES-CBC",
                                                      'iv' : iv
                                                    },true,["sign"])
    set_current_session_signing_key(priv_key)
    set_current_session_email(user_information.email)
  }


  async function wv_setup_crypto() {
    if ( g_window_can_process && g_crypto && g_audio_db ) {
      //
      let user_info = null
      try {
        user_info = await wv_find_user('wave_recording_session_user')
        wv_restore_signing_key(user_info)
        wv_user_info_to_worker(user_info)
      } catch (e) {
        wv_ask_create_user('wave_recording_session_user')
      }
      
    } else {
      alert("Crypotgraphy processing is not available within this browser at this time.")
    }
  }

  // ---- ---- ---- ---- ---- ----
  // ---- ---- ---- ---- ---- ----
  if ( g_window_can_process ) {
    init_user_dialog()
    wv_init_database(gc_song_db_name)
    wv_initialize_global_buttons()
    wv_init_recorder()
    wv_getLocation()
  }

</script>