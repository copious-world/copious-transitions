//
const fs = require('fs')
const conf_obj = load_parameters()                  // configuration parameters to select modules, etc.
// CONFIGURE
const g_db = require(conf_obj.db_module)            // The database interface.
const g_middleware = require(conf_obj.middleware)   // This is middleware for Express applications
const g_authorizer = require(conf_obj.authorizer)   // Put authorization mechanics here.
const g_validator = require(conf_obj.validator)     // For posts, some posts will have fields that should be accepted or rejected depending on type, etc.
const g_statics = require(conf_obj.static_assets)   // Special handling for fetching static assets.
//
var express = require('express');
var g_app = express()
//
// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

// INITIALIZE
let g_session_manager = g_authorizer.sessions(g_app,g_db)   // setup session management, session, cookies, tokens, etc. Use database and Express api.
g_middleware.setup(g_app,g_db,g_session_manager)            // use a module to cusomize the use of Express middleware.
g_validator.initialize(g_db,g_session_manager)              // The validator may refer to stored items and look at other context dependent information
g_statics.initialize(g_db)                                  // Static assets may be taken out of DB storage or from disk, etc.


// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

// ROOT ... unauthorized entry point
g_app.get('/', (req, res) => {
    var html = g_statics.fetch('index.html');
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(html);
});

// STATIC FETCH
g_app.get('/static_mime/:asset', (req, res) => {
    let asset = req.params['asset']
    if ( g_session_manager.check(asset,req) ) {     // returns a true value by default, but may guard some assets
        var asset_obj = g_statics.fetch(asset);     // returns an object with fields mime_type, and string e.g. text/html with uriEncoded html
        res.writeHead(200, { 'Content-Type': asset_obj.mime_type });
        res.end(asset_obj.string);    
    } else {
        res.status(200).send(JSON.stringify( { 'type' : 'user', 'OK' : 'false', 'reason' : 'unavailable' }));
    }
});


// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

// KEYED MIME_TYPES  -- no validation check on the post, so only a key is expected
let g_secondary_mime_actions = {}
g_app.post('/keyed_mime/:asset', (req, res) => {
    let asset = req.params['asset']
    if ( g_session_manager.check(asset,req) ) {             // asset exits, permission granted, etc.
        let transtionObj = g_session_manager.process_asset(asset,body)  // not checking sesion, key the asset and use any search refinement in the body.
        if ( transtionObj.secondary_action ) {                          // return a transition object to go to the client. 
            let asset_obj = g_statics.fetch(asset);                     // get the asset for later
            g_secondary_mime_actions[transtionObj.token] = { 'tobj' : transtionObj, 'asset' : asset_obj }               // store the object and the asset. 
            return(res.status(200).send(JSON.stringify({ 'type' : 'user', 'OK' : 'true', 'data' : transtionObj })));    // transition object has token
        } else {
            let asset_obj = g_statics.fetch(asset);     // no checks being done, just send the asset. No token field included
            res.writeHead(200, { 'Content-Type': asset_obj.mime_type } );
            return(res.end(asset_obj.string));
        }
    }
    res.status(200).send(JSON.stringify({ 'type' : 'user', 'OK' : 'false', 'reason' : 'unavailable' }));
});

// KEYED MIME_TYPES  - TRANSITION ACCEPTED  -- the body should send back the token it got with the asset.
g_app.post('/keyed_mime/secondary',(req,res) => {
    let body = req.body
    if ( body.token !== undefined ) {
        let cached_transition = g_secondary_mime_actions[body.token]            // take the asset information from cache
        if ( cached_transition !== undefined ) {
            let transtionObj = cached_transition.tobj
            if ( g_session_manager.match(body,transtionObj)  ) {                // check on matching tokens and possibly other things
                let asset_obj = cached_transition.data                          // Finally, send the asset 
                res.writeHead(200, { 'Content-Type': asset_obj.mime_type } );
                return(res.end(asset_obj.string));
            }
        }
    }
    res.status(200).send(JSON.stringify( { 'type' : 'secondary/action', 'OK' : 'false', 'reason' : 'missing data' }));
})


// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

// TRANSITIONS - pure state transition dynamics for sessions
let g_finalize_transitions = {}
g_app.post('/transition/:transition', function(req, res){           // the transition is a name or key
    let body = req.body
    let transition = req.params.transition
    if ( g_validator.valid(body,conf_obj.field_set[transition]) ) {         // A field set may be in configuration for named transitions - true by default
        if ( g_session_manager.feasable(body,req) ) {                       // can this session actually make the transition?
            let transtionObj = g_session_manager.process_transition(transition,body,req)            // either fetch or produced transition data
            if ( transtionObj.secondary_action ) {                          // Require a seconday action as part of the transition for finalization
                let elements = g_statics.fetch_elements(transition);        // elements is purposely vague and may be application sepecific
                g_finalize_transitions[transtionObj.token] = { 'tobj' : transtionObj, 'elements' : elements }
                return(res.status(200).send(JSON.stringify({ 'type' : 'user', 'OK' : 'true', 'data' : transtionObj, 'elements' : elements })));
            }
        }
    }
    res.status(200).send(JSON.stringify({ 'type' : 'user', 'OK' : 'false', 'reason' : 'unavailable' }));
});

// TRANSITIONS  - TRANSITION ACCEPTED  -- the body should send back the token it got with the asset.
g_app.post('/transition/secondary',(req,res) => {
    let body = req.body
    if ( body.token !== undefined ) {
        let cached_transition = g_finalize_transitions[body.token]      // get the transition from cache
        if ( cached_transition !== undefined ) {
            let transtionObj = cached_transition.tobj
            if ( g_session_manager.match(body,transtionObj)  ) {        // check on matching tokens and possibly other things 
                let elements = cached_transition.elements
                // some kind of transition takes place and becomes the state of the session. It may not be the same as the one
                // specified in the cached transition, but may be similar depending on how types (categories) are regulated 
                let finalization_state = g_session_manager.finalize_transition(body,elements)      // FINALIZE (not a final state)
                if ( finalization_state ) {     // relay the finalized transition and go on with business. 
                    return(res.status(200).send(JSON.stringify({ 'type' : 'finalize', 'OK' : 'true', 'state' : finalization_state, 'reason' : 'matched' })));
                } // else nothing worked 
            }
        }
    }
    res.status(200).send(JSON.stringify({ 'type' : 'secondary/action', 'OK' : 'false', 'reason' : 'no transition' }));
})



// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

// USER MANAGEMENT - handle authorization and user presence.
let g_secondary_user_actions = {}
g_app.post(['/users/login','/users/logout','/users/register','/users/forgot'],(req,res) => {
    let body = req.body
    let user_op = body['action']
    if ( g_validator.valid(body,conf_obj.field_set[user_op]) ) {        // every post that comes through will have validation from configuration
        let transtionObj = g_session_manager.process_user(body)         // most paths require secondation action (perhaps logout doesn't) (Captch as model)
        if ( transtionObj.secondary_action ) {
            g_secondary_user_actions[transtionObj.token] = { 'tobj' : transtionObj, 'token' : transtionObj.session_token, 'action' : user_op }
            delete transtionObj.session_token
            return(res.status(200).send(JSON.stringify( { 'type' : 'user', 'OK' : 'true', 'data' : transtionObj })));
        } else {
            return(res.status(200).send(JSON.stringify( { 'type' : 'user', 'OK' : 'true', 'data' : transtionObj })));
        }
    }    
    res.status(200).send(JSON.stringify( { 'type' : 'user', 'OK' : 'false', 'reason' : 'bad form' }));
})
 
// USER MANAGEMENT - finalize the user action.
g_app.post('/users/secondary/:action',(req,res) => {
    let body = req.body
    let action = req.params['action']
    if ( body.token !== undefined ) {                                   // the token must be present
        let cached_transition = g_secondary_user_actions[body.token]
        if ( (cached_transition !== undefined) && (action == cached_transition.action) ) {      // the action must match (artifac of use an array of paths)
            // this is the asset needed by the client to turn on personlization and key access (aside from sessions and cookies)
            let session_token = cached_transition.session_token
            let transtionObj = cached_transition.tobj
            if ( g_session_manager.match(body,transtionObj)  ) {        // check the tokens and any other application specific information required
                res.status(200).send(JSON.stringify({ 'type' : transtionObj.type, 'OK' : 'true', 'reason' : 'match', 'token' : session_token }));
                return;
            }
        }
    }
    res.status(200).send(JSON.stringify( { 'type' : 'secondary/action', 'OK' : 'false', 'reason' : 'missing data' }));
})



// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------



g_app.listen(conf_obj.port);



// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------
// ------------- ------------- ------------- ------------- ------------- ------------- ------------- -------------

function load_parameters() {
    let config = "./user-service.conf"
    if ( process.argv[2] !== undefined ) {
        config = process.argv[2];
    }
    try {
        let confJSON = JSON.parse(fs.readFileSync(config,'ascii').toString())
        return(confJSON)
    } catch (e) {
        console.log(e)
        process.exit(1)
    }
}

